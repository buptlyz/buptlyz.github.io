<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="高亮划词,在线笔记,">










<meta name="description" content="原文链接 需要解决的核心问题：  加高亮背景。即如何根据用户在网页上的选取，为响应的文本添加高亮背景 高亮区域的持久化与还原。即如何保存用户高亮信息，并在下次浏览时准确还原。  如何加高亮背景基本思路如下：  获取选中的文本节点：通过用户选择的区域信息，获取所有被选中的所有文本节点 为文本节点添加背景色：给这些文本节点包裹一层新的元素，该元素具有指定的背景颜色。  如何获取选中的文本节点？Sele">
<meta name="keywords" content="高亮划词,在线笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="如何用js实现“高亮划词”的在线笔记功能(转)">
<meta property="og:url" content="https://buptlyz.github.io/2019/04/25/如何用js实现“高亮划词”的在线笔记功能-转/index.html">
<meta property="og:site_name" content="沙雕爹爹">
<meta property="og:description" content="原文链接 需要解决的核心问题：  加高亮背景。即如何根据用户在网页上的选取，为响应的文本添加高亮背景 高亮区域的持久化与还原。即如何保存用户高亮信息，并在下次浏览时准确还原。  如何加高亮背景基本思路如下：  获取选中的文本节点：通过用户选择的区域信息，获取所有被选中的所有文本节点 为文本节点添加背景色：给这些文本节点包裹一层新的元素，该元素具有指定的背景颜色。  如何获取选中的文本节点？Sele">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/4/20/16a3b78be942a10d?w=2354&h=858&f=png&s=216507">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/4/20/16a3b62dd95bac60?w=1195&h=720&f=gif&s=881043">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/4/21/16a3f9a22e744782?w=1916&h=514&f=png&s=142468">
<meta property="og:updated_time" content="2019-08-13T07:54:29.921Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何用js实现“高亮划词”的在线笔记功能(转)">
<meta name="twitter:description" content="原文链接 需要解决的核心问题：  加高亮背景。即如何根据用户在网页上的选取，为响应的文本添加高亮背景 高亮区域的持久化与还原。即如何保存用户高亮信息，并在下次浏览时准确还原。  如何加高亮背景基本思路如下：  获取选中的文本节点：通过用户选择的区域信息，获取所有被选中的所有文本节点 为文本节点添加背景色：给这些文本节点包裹一层新的元素，该元素具有指定的背景颜色。  如何获取选中的文本节点？Sele">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/4/20/16a3b78be942a10d?w=2354&h=858&f=png&s=216507">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://buptlyz.github.io/2019/04/25/如何用js实现“高亮划词”的在线笔记功能-转/">





  <title>如何用js实现“高亮划词”的在线笔记功能(转) | 沙雕爹爹</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沙雕爹爹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay foolish, stay humble.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/如何用js实现“高亮划词”的在线笔记功能-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">如何用js实现“高亮划词”的在线笔记功能(转)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T19:19:30+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://segmentfault.com/a/1190000018981813" target="_blank" rel="noopener">原文链接</a></p>
<p>需要解决的核心问题：</p>
<ul>
<li>加高亮背景。即如何根据用户在网页上的选取，为响应的文本添加高亮背景</li>
<li>高亮区域的持久化与还原。即如何保存用户高亮信息，并在下次浏览时准确还原。</li>
</ul>
<h2 id="如何加高亮背景"><a href="#如何加高亮背景" class="headerlink" title="如何加高亮背景"></a>如何加高亮背景</h2><p>基本思路如下：</p>
<ol>
<li>获取选中的文本节点：通过用户选择的区域信息，获取所有被选中的所有文本节点</li>
<li>为文本节点添加背景色：给这些文本节点包裹一层新的元素，该元素具有指定的背景颜色。</li>
</ol>
<h3 id="如何获取选中的文本节点？"><a href="#如何获取选中的文本节点？" class="headerlink" title="如何获取选中的文本节点？"></a>如何获取选中的文本节点？</h3><h4 id="Selection-API"><a href="#Selection-API" class="headerlink" title="Selection API"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a></h4><p>兼容性还不错，如果需要支持更低版本，需要polyfill。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/20/16a3b78be942a10d?w=2354&amp;h=858&amp;f=png&amp;s=216507" alt="Selection API"></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a>可以返回一系列关于用户选区的信息。那么是不是可以通过它直接获取选取中的所有DOM元素呢？</p>
<p>很遗憾并不能。但好在它可以返回选区但首尾节点信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> range = <span class="built_in">window</span>.getSelection().getRangeAt(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> start = &#123;</span><br><span class="line">  node: range.startContainer,</span><br><span class="line">  offset: range.startOffset</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> end = &#123;</span><br><span class="line">  node: range.endContainer,</span><br><span class="line">  offset: range.endOffset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Range</code>对象包含了选区但开始与结束信息，其中包括节点(node)与文本偏移量(offset)。节点信息不用多说，这里解释一下<code>offset</code>是指什么：例如，标签<code>&lt;p&gt;This is a paragraph.&lt;/p&gt;</code>，用户选取但部分是<code>a paragraph</code>这两个词，这是首尾的<code>node</code>均为<code>p</code>元素内的文本节点(<code>Text Node</code>)，而<code>startOffset</code>和<code>endOffset</code>分别为<code>2</code>和<code>6</code>。</p>
<blockquote>
<p>为了获取用户当前选中的文本，可以使用<code>Window.getSelection()</code>或者<code>Document.getSelection()</code>方法。它们返回一个[<code>Selection</code>][]对象，你可以用一个变量存储它。<br>你可以对你存储的<code>selection</code>执行很多操作，如调用<code>Selection.toString()</code>方法拷贝一份文本字符串，或者使用<code>Selection.addRange()</code>/<code>Selection.removeRange()</code>给这个<code>selection</code>添加/删除一个范围(正如标准<code>Rnage</code>对象展示的)，又或者使用<code>Selection.selectAllChildren()</code>修改<code>selection</code>为这个DOM节点的全部内容。<br>当<code>selection</code>有变化，或者新的<code>selection</code>被创建时，使用<code>GlobalEventHandlers.onselectionchange</code>和<code>GlobalEventHandlers.onselectstart</code>事件处理函数里可以执行你的代码。</p>
</blockquote>
<h4 id="首尾文本节点拆分"><a href="#首尾文本节点拆分" class="headerlink" title="首尾文本节点拆分"></a>首尾文本节点拆分</h4><p>理解了<code>offset</code>的概念后，自然就会发现有个问题需要解决。由于用户选区(<code>selection</code>)可能只包含一个文本节点的一部分(即<code>offset</code>不为0)，所以我们最后得到的用户选区所包含的节点里，也只希望有首尾文本节点的这一部分。对此，我们可以使用<code>.splitText()</code>拆分文本节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首节点</span></span><br><span class="line"><span class="keyword">if</span> (curNode === $startNode) &#123;</span><br><span class="line">  <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">    curNode.splitText(startOffset);</span><br><span class="line">    <span class="keyword">const</span> node = curNode.nextSibling;</span><br><span class="line">    selectedNodes.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">if</span> (curNode === $endNode) &#123;</span><br><span class="line">  <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = curNode;</span><br><span class="line">    node.splitText(endOffset);</span><br><span class="line">    selectedNodes.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会依据<code>offset</code>对文本节点进行拆分。对于开始节点，只需要收集它的后半部分；而对于结束节点则是前半部分。</p>
<h4 id="遍历DOM树"><a href="#遍历DOM树" class="headerlink" title="遍历DOM树"></a>遍历DOM树</h4><p>到目前为止，我们准确找到了首尾节点，所以下一步就是找出“中间”所有的文本节点。这就需要遍历DOM树。</p>
<p>“中间”加上引号是因为，在视觉上，这些节点是位于首尾之间的，但由于DOM不是线性结构而是树形结构，所以这个“中间”换成程序语言，就是指深度优先遍历时，位于首尾节点之间的所有文本节点。DFS的方法有很多，可以递归，也可以用栈+循环，这里就不赘述了。</p>
<p>需要提一下的是，由于我们是要为文本节点添加高亮背景，因此在遍历时只会收集文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">  selectedNodes.push(curNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何为文本节点添加背景色？"><a href="#如何为文本节点添加背景色？" class="headerlink" title="如何为文本节点添加背景色？"></a>如何为文本节点添加背景色？</h3><p>一个最直接的方法就是为选中的文本节点(包括分拆后的首尾节点)“包裹上”一个带背景样式的元素。</p>
<p>具体的，我们可以给每个文本节点加上一个<code>class</code>为<code>highlight</code>的<code>span</code>元素；而背景样式则通过<code>.highlight</code>选择器设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面封装的方法</span></span><br><span class="line"><span class="keyword">const</span> nodes = getSelectedNodes(start, end);</span><br><span class="line"></span><br><span class="line">nodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrap = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">  wrap.setAttribute(<span class="string">'class'</span>, <span class="string">'highlight'</span>);</span><br><span class="line">  wrap.appendChild(node.cloneNode(<span class="literal">false</span>));</span><br><span class="line">  node.parentNode.replaceChild(wrap);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>p.s.</strong> 选区的重合问题</p>
<p>举个例子：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/20/16a3b62dd95bac60?w=1195&amp;h=720&amp;f=gif&amp;s=881043" alt="选区的重合问题"></p>
<p>具体解决后面再说。</p>
<h2 id="如何实现高亮选取的持久化与还原？"><a href="#如何实现高亮选取的持久化与还原？" class="headerlink" title="如何实现高亮选取的持久化与还原？"></a>如何实现高亮选取的持久化与还原？</h2><blockquote>
<p>持久化高亮选区的核心是找到一种合适的DOM节点序列化方法。</p>
</blockquote>
<p>通过第三部分可以知道，当确定了首尾节点与文本偏移（offset）信息后，即可为其间文本节点添加背景色。其中，offset 是数值类型，要在服务器保存它自然没有问题；但是 DOM 节点不同，在浏览器中保存它只需要赋值给一个变量，但想在后端保存所谓的 DOM 则不那么直接了。</p>
<h3 id="序列化DOM节点知识"><a href="#序列化DOM节点知识" class="headerlink" title="序列化DOM节点知识"></a>序列化DOM节点知识</h3><p>所以这里的核心点就是找到一种方法，能够定位DOM节点，同时可以被保存成普通的<code>JSON</code>，用以传给后端保存，这个过程在本文中被称为DOM标识的“序列化”。而下次用户访问时，又可以从后端取回，然后“反序列化”为对应的DOM节点。</p>
<p>有几种常见的方式来标识DOM节点：</p>
<ul>
<li>使用<code>xPath</code></li>
<li>使用<code>CSS Selector</code>语法</li>
<li>使用<code>tagName + index</code></li>
</ul>
<p>这里选择第三种方法。</p>
<p>需要注意的一点，我们通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a>取到的首尾节点一般是文本节点，而这里要记录的<code>tagName</code>和<code>index</code>都是该文本节点的父元素节点(<code>Element Node</code>)的，而<code>childIndex</code>表示该文本节点是其父节点的第几个子节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serialize = <span class="function">(<span class="params">textNode, root = <span class="built_in">document</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = textNode.parentElement;</span><br><span class="line">  <span class="keyword">let</span> childIndex = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = node.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (textNode === node.childNodes[i]) &#123;</span><br><span class="line">      childIndex = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tagName = node.tagName;</span><br><span class="line">  <span class="keyword">const</span> list = root.getElementsByTagName(tagName);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>, len = list.length; index &lt; len; index++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === list[index]) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;tagName, index, childIndex&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;tagName, <span class="attr">index</span>: <span class="number">-1</span>, childIndex&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该方法返回的信息，再加上<code>offset</code>的信息，即定位选取的起始位置，同时也完全可以发送给后端进行保存了。</p>
<h3 id="反序列化DOM节点"><a href="#反序列化DOM节点" class="headerlink" title="反序列化DOM节点"></a>反序列化DOM节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deSerialize = <span class="function">(<span class="params">meta, root = <span class="built_in">document</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;tagName, index, childIndex&#125; = meta;</span><br><span class="line">  <span class="keyword">const</span> parent = root.getElementsByTagName(tagName)[index];</span><br><span class="line">  <span class="keyword">return</span> parent.childNodes[childIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经解决了两个核心问题，这似乎已经是一个可用版本了。但<strong>其实不然</strong>，根据实践经验，如果仅仅是上面这些处理，往往是无法应对实际需求的，存在一些“致命问题”。</p>
<h2 id="如何实现一个生产环境可用的“划词高亮”？"><a href="#如何实现一个生产环境可用的“划词高亮”？" class="headerlink" title="如何实现一个生产环境可用的“划词高亮”？"></a>如何实现一个生产环境可用的“划词高亮”？</h2><h3 id="上面的方案有什么问题？"><a href="#上面的方案有什么问题？" class="headerlink" title="上面的方案有什么问题？"></a>上面的方案有什么问题？</h3><p>首先来看看上面的方案会有什么问题。</p>
<p>当我们需要高亮文本时，会为文本节点包裹<code>span</code>元素，这就改动了页面的 DOM 结构。它可能会导致后续高亮的首尾节点与其 <code>offset</code> 信息其实是基于被改动后的 DOM 结构的。带来的结果有两个：</p>
<ul>
<li>下次访问时，程序必须按上次用户高亮的顺序还原。</li>
<li>用户不能随意取消（删除）高亮区域，只能按添加顺序从后往前删。</li>
</ul>
<p>否则，就会有部分的高亮选区在还原时无法定位到正确的元素。</p>
<p>文字可能不好理解，下面我举个例子来直观解释下这个问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常高兴今天能够在这里和大家分享一下文本高亮（在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于上面这段 HTML，用户分别按顺序高亮了两个部分：“高兴”和“文本高亮”。那么按照上面的实现方式，这段 HTML 变成了下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高兴<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    今天能够在这里和大家分享一下</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>文本高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    （在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应的两个序列化数据分别为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “高兴”两个字被高亮时获取的序列化信息</span></span><br><span class="line">&#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">0</span>,</span><br><span class="line">        offset: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">0</span>,</span><br><span class="line">        offset: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “文本高亮”四个字被高亮时获取的序列化信息。</span></span><br><span class="line"><span class="comment">// 这时候由于p下面已经存在了一个高亮信息（即“高兴”）。</span></span><br><span class="line"><span class="comment">// 所以其内部 HTML 结构已被修改，直观来说就是 childNodes 改变了。</span></span><br><span class="line"><span class="comment">// 进而，childIndex属性由于前一个 span 元素的加入，变为了 2。</span></span><br><span class="line">&#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">2</span>,</span><br><span class="line">        offset: <span class="number">14</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">2</span>,</span><br><span class="line">        offset: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，“文本高亮”这四个字的首尾节点的 <code>childIndex</code> 都被记为 2，这是由于前一个高亮区域改变了<code>p</code>元素下的DOM结构。如果此时“高兴”选区的高亮被用户取消，那么下次再访问页面就无法还原高亮了 —— “高兴”选区的高亮被取消了，<code>p</code>下自然就不会出现第三个 <code>childNode</code>，那么 <code>childIndex</code> 为 2 就找不到对应的节点了。这就导致存储的数据在还原高亮选区时出现问题。</p>
<p>此外，还记得在第三部分末尾提到的高亮选取重合问题么？支持选取重合很容易出现如下的包裹元素嵌套情况：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高兴<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    今天能够在这里和大家分享一下</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span></span><br><span class="line">        文本</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    （在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这也使得某个文本区域经过多次高亮、取消高亮后，会出现与原 HTML 页面不同的复杂嵌套结构。可以预见，当我们使用 <code>xpath</code> 或 <code>CSS selector</code> 作为 DOM 标识时，上面提到的问题也会出现，同时也使其他需求的实现更加复杂。</p>
<p>到这里可以提一下其他开源库或产品是如何处理选区重合问题的：</p>
<ul>
<li>开源库 <a href="https://github.com/timdown/rangy" target="_blank" rel="noopener">Rangy</a> 有一个 <code>Highlighter</code> 模块可以实现文本高亮，但其对于选区重合的情况是将两个选区直接合并了，这是不合符我们业务需求的。</li>
<li>付费产品 <a href="https://chrome.google.com/webstore/detail/pnhplgjpclknigjpccbcnmicgcieojbh" target="_blank" rel="noopener">Diigo</a> 直接不允许选区的重合。</li>
<li><a href="https://medium.com/" target="_blank" rel="noopener">Medium.com</a> 是支持选区重合的，体验非常不错，这也是我们产品的目标。但它页面的内容区结构相较我面对的情况会更简单与更可控。</li>
</ul>
<p>所以如何解决这些问题呢？</p>
<h3 id="另一种序列化-反序列化方式"><a href="#另一种序列化-反序列化方式" class="headerlink" title="另一种序列化/反序列化方式"></a>另一种序列化/反序列化方式</h3><p>我会对第四部分提到的序列化方式进行改进。仍然记录文本节点的父节点 <code>tagName</code> 与 <code>index</code>，但不再记录文本节点在 <code>childNodes</code> 中的 <code>index</code> 与 <code>offset</code>，而是记录开始（结束）位置在整个父元素节点中的文本偏移量。</p>
<p>例如下面这段 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高兴<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    今天能够在这里和大家分享一下</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>文本高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    （在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于“文本高亮”这个高亮选区，之前用于标识文本起始位置的信息为<code>childIndex = 2</code>，<code>offset = 14</code>。而现在变为<code>offset = 18</code>（从<code>p</code>元素下第一个文本“非”开始计算，经过18个字符后是“文”）。可以看出，这样表示的优点是，不管<code>p</code>内部原有的文本节点被<code>span</code>（包裹）节点如何分割，都不会影响高亮选区还原时的节点定位。</p>
<p>据此，在序列化时，我们需要一个方法来将文本节点内偏移量“翻译”为其对应的父节点内部的总体文本偏移量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTextPreOffset</span>(<span class="params">root, text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodeStack = [root];</span><br><span class="line">    <span class="keyword">let</span> curNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode = nodeStack.pop()) &#123;</span><br><span class="line">        <span class="keyword">const</span> children = curNode.childNodes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = children.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            nodeStack.push(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span> &amp;&amp; curNode !== text) &#123;</span><br><span class="line">            offset += curNode.textContent.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而还原高亮选区时，需要一个对应的逆过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTextChildByOffset</span>(<span class="params">parent, offset</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodeStack = [parent];</span><br><span class="line">    <span class="keyword">let</span> curNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> startOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode = nodeStack.pop()) &#123;</span><br><span class="line">        <span class="keyword">const</span> children = curNode.childNodes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = children.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            nodeStack.push(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">            startOffset = offset - curOffset;</span><br><span class="line">            curOffset += curNode.textContent.length;</span><br><span class="line">            <span class="keyword">if</span> (curOffset &gt;= offset) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!curNode) &#123;</span><br><span class="line">        curNode = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">node</span>: curNode, <span class="attr">offset</span>: startOffset&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="支持高亮选区的重合"><a href="#支持高亮选区的重合" class="headerlink" title="支持高亮选区的重合"></a>支持高亮选区的重合</h3><p>重合的高亮选区带来的一个问题就是高亮包裹元素的嵌套，从而使得 DOM 结构会有较复杂的变动，增加了其他功能（交互）实现与问题排查的复杂度。因此，我在前面提到的包裹高亮元素时，会再进行一些稍复杂的处理（尤其是重合选区），以保证尽量复用已有的包裹元素，避免元素的嵌套。</p>
<p>在处理时，将需要包裹的各个文本片段(<code>Text Node</code>)分为三类情况：</p>
<ol>
<li>完全未被包裹，则直接包裹该部分。</li>
<li>属于被包裹过的文本节点的一部分，则使用<code>.splitText()</code>将其拆分。</li>
<li>是一段完全被包裹的文本段，不需要对节点进行处理。</li>
</ol>
<p>与此同时，为每个选区生成唯一 ID，将该段文本几点多对应的 ID、以及其由于选区重合所涉及到的其他 ID，都附加包裹元素上。因此像上面的第三种情况，不需要变更 DOM 结构，只用更新包裹元素两类 ID 所对应的 <code>dataset</code> 属性即可。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>解决以上的一些问题后，“文本划词高亮”就基本可用了。还剩下一些“小修补”，简单提一下。</p>
<h3 id="高亮选区的交互事件，例如-click、hover"><a href="#高亮选区的交互事件，例如-click、hover" class="headerlink" title="高亮选区的交互事件，例如 click、hover"></a>高亮选区的交互事件，例如 <code>click</code>、<code>hover</code></h3><p>首先，可以为每个高亮选区生成一个唯一 ID，然后在该选区内所有的包裹元素上记录该 ID 信息，例如用<code>data-highlight-id</code>属性。而对于选取重合的部分可以在<code>data-highlight-extra-id</code>属性中记录重合的其他选区的 ID。</p>
<p>而监听到包裹元素的 <code>click</code>、<code>hover</code> 后，则触发 <code>highlighter</code> 的相应事件，并带上高亮 ID。</p>
<h3 id="取消高亮（高亮背景的删除）"><a href="#取消高亮（高亮背景的删除）" class="headerlink" title="取消高亮（高亮背景的删除）"></a>取消高亮（高亮背景的删除）</h3><p>由于在包裹时支持选区重合（对应会有上面提到的三种情况需要处理），因此，在删除选取高亮时，也会有三种情况需要分别处理：</p>
<ul>
<li>直接删除包裹元素。即不存在选区重合。</li>
<li>更新data-highlight-id属性和data-highlight-extra-id属性。即删除的高亮 ID 与 data-highlight-id 相同。</li>
<li>只更新data-highlight-extra-id属性。即删除的高亮 ID 只在 data-highlight-extra-id 中。</li>
</ul>
<h3 id="对于前端生成的动态页面怎么办？"><a href="#对于前端生成的动态页面怎么办？" class="headerlink" title="对于前端生成的动态页面怎么办？"></a>对于前端生成的动态页面怎么办？</h3><p>不难发现，这种非耦合的文本高亮功能很依赖于页面的 DOM 结构，需要保证做高亮时的 DOM 结构和还原时的一致，否则无法正确还原出选区的起始节点位置。据此，对“划词”高亮最友好的应该是纯后端渲染的页面，在<code>onload</code>监听中触发高亮选区还原的方法即可。但目前越来越多的页面（或页面的一部分）是前端动态生成的，针对这个问题该怎么处理呢？</p>
<p>我在实际工作中也遇到了类似问题 —— 页面的很多区域是 ajax 请求后前端渲染的。我的处理方式包括如下：</p>
<ul>
<li>隔离变化范围。将上述代码中的“根节点”从<code>documentElement</code>换为另一个更具体的容器元素。例如我面对的业务会在 id 为 <code>article-container</code> 的<code>div</code>内加载动态内容，那么我就会指定这个 <code>article-container</code> 为“根节点”。这样可以最大程度防止外部的 DOM 变动影响到高亮位置的定位，尤其是页面改版。</li>
<li>确定高亮选区的还原时机。由于内容可能是动态生成，所以需要等到该部分的 DOM 渲染完成后再调用还原方法。如果有暴露的监听事件可以在监听内处理；或者通过 <code>MutationObserver</code> 监听标志性元素来判断该部分是否加载完成。</li>
<li>记录业务内容信息，应对内容区改版。内容区的 DOM 结构更改算是“毁灭性打击”。如何确实有该类情况，可以尝试让业务内容展示方将段落信息等具体的内容信息绑定在 DOM 元素上，而我在高亮时取出这些信息来冗余存储，改版后可以通过这些内容信息“刷”一遍存储的数据。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>篇幅问题，还有其他细节的问题就不在这篇文章里分享了。详细内容可以参考 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">web-highlighter</a> 这个仓库里的实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先从“划词高亮”功能的两个核心问题（如何高亮用户选区的文本、如何将高亮选区还原）切入，基于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a>、深度优先遍历和 DOM 节点标识的序列化这些手段实现了“划词高亮”的核心功能。然而，该方案仍然存在一些实际问题，因此在第 5 部分进一步给出了相应的解决方案。</p>
<p>基于实际开发的经验，我发现解决上述几个“划词高亮”核心问题的代码具有一定通用性，因此把核心部分的源码封装成了独立的库 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">web-highlighter</a>，托管在 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">github</a>，也可以通过 <code>npm</code> 安装。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/21/16a3f9a22e744782?w=1916&amp;h=514&amp;f=png&amp;s=142468" alt="web-highlighter"></p>
<p>其已服务于线上产品业务，基本的高亮功能一行代码即可开启：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Highlighter()).run();</span><br></pre></td></tr></table></figure>
<p>兼容IE 10/11、Edge、Firefox 52+、Chrome 15+、Safari 5.1+、Opera 15+。</p>
<p>感兴趣的小伙伴可以 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">star</a> 一下。感谢支持，欢迎交流 😊</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/高亮划词/" rel="tag"># 高亮划词</a>
          
            <a href="/tags/在线笔记/" rel="tag"># 在线笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/25/JS异步捕获二三事-转/" rel="next" title="JS异步捕获二三事(转)">
                <i class="fa fa-chevron-left"></i> JS异步捕获二三事(转)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/25/2019前端开发手册/" rel="prev" title="2019前端开发手册(转)">
                2019前端开发手册(转) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">沙雕爹爹</p>
              <p class="site-description motion-element" itemprop="description">Personal tech blog.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何加高亮背景"><span class="nav-number">1.</span> <span class="nav-text">如何加高亮背景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何获取选中的文本节点？"><span class="nav-number">1.1.</span> <span class="nav-text">如何获取选中的文本节点？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Selection-API"><span class="nav-number">1.1.1.</span> <span class="nav-text">Selection API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#首尾文本节点拆分"><span class="nav-number">1.1.2.</span> <span class="nav-text">首尾文本节点拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历DOM树"><span class="nav-number">1.1.3.</span> <span class="nav-text">遍历DOM树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何为文本节点添加背景色？"><span class="nav-number">1.2.</span> <span class="nav-text">如何为文本节点添加背景色？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现高亮选取的持久化与还原？"><span class="nav-number">2.</span> <span class="nav-text">如何实现高亮选取的持久化与还原？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化DOM节点知识"><span class="nav-number">2.1.</span> <span class="nav-text">序列化DOM节点知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反序列化DOM节点"><span class="nav-number">2.2.</span> <span class="nav-text">反序列化DOM节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现一个生产环境可用的“划词高亮”？"><span class="nav-number">3.</span> <span class="nav-text">如何实现一个生产环境可用的“划词高亮”？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#上面的方案有什么问题？"><span class="nav-number">3.1.</span> <span class="nav-text">上面的方案有什么问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#另一种序列化-反序列化方式"><span class="nav-number">3.2.</span> <span class="nav-text">另一种序列化/反序列化方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持高亮选区的重合"><span class="nav-number">3.3.</span> <span class="nav-text">支持高亮选区的重合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他问题"><span class="nav-number">4.</span> <span class="nav-text">其他问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高亮选区的交互事件，例如-click、hover"><span class="nav-number">4.1.</span> <span class="nav-text">高亮选区的交互事件，例如 click、hover</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消高亮（高亮背景的删除）"><span class="nav-number">4.2.</span> <span class="nav-text">取消高亮（高亮背景的删除）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于前端生成的动态页面怎么办？"><span class="nav-number">4.3.</span> <span class="nav-text">对于前端生成的动态页面怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">4.4.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沙雕爹爹</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
