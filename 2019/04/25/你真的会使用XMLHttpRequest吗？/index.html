<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="XHR,">










<meta name="description" content="原文链接 看到标题时，有些同学可能会想：“我已经用xhr成功地发过很多个Ajax请求了，对它的基本操作已经算挺熟练了。” 我之前的想法和你们一样，直到最近我使用xhr时踩了不少坑儿，我才突然发现其实自己并不够了解xhr，我知道的只是最最基本的使用。 于是我决定好好地研究一番xhr的真面目，可拜读了不少博客后都不甚满意，于是我决定认真阅读一遍W3C的XMLHttpRequest标准。看完标准后我如同">
<meta name="keywords" content="XHR">
<meta property="og:type" content="article">
<meta property="og:title" content="你真的会使用XMLHttpRequest吗？(转)">
<meta property="og:url" content="https://buptlyz.github.io/2019/04/25/你真的会使用XMLHttpRequest吗？/index.html">
<meta property="og:site_name" content="沙雕爹爹">
<meta property="og:description" content="原文链接 看到标题时，有些同学可能会想：“我已经用xhr成功地发过很多个Ajax请求了，对它的基本操作已经算挺熟练了。” 我之前的想法和你们一样，直到最近我使用xhr时踩了不少坑儿，我才突然发现其实自己并不够了解xhr，我知道的只是最最基本的使用。 于是我决定好好地研究一番xhr的真面目，可拜读了不少博客后都不甚满意，于是我决定认真阅读一遍W3C的XMLHttpRequest标准。看完标准后我如同">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://image-static.segmentfault.com/174/902/1749021644-569b9fb8d3b4a_articlex">
<meta property="og:updated_time" content="2019-08-13T07:54:29.919Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你真的会使用XMLHttpRequest吗？(转)">
<meta name="twitter:description" content="原文链接 看到标题时，有些同学可能会想：“我已经用xhr成功地发过很多个Ajax请求了，对它的基本操作已经算挺熟练了。” 我之前的想法和你们一样，直到最近我使用xhr时踩了不少坑儿，我才突然发现其实自己并不够了解xhr，我知道的只是最最基本的使用。 于是我决定好好地研究一番xhr的真面目，可拜读了不少博客后都不甚满意，于是我决定认真阅读一遍W3C的XMLHttpRequest标准。看完标准后我如同">
<meta name="twitter:image" content="https://image-static.segmentfault.com/174/902/1749021644-569b9fb8d3b4a_articlex">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://buptlyz.github.io/2019/04/25/你真的会使用XMLHttpRequest吗？/">





  <title>你真的会使用XMLHttpRequest吗？(转) | 沙雕爹爹</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沙雕爹爹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay foolish, stay humble.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/你真的会使用XMLHttpRequest吗？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">你真的会使用XMLHttpRequest吗？(转)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T14:29:29+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://segmentfault.com/a/1190000004322487#articleHeader13" target="_blank" rel="noopener">原文链接</a></p>
<p>看到标题时，有些同学可能会想：“我已经用xhr成功地发过很多个Ajax请求了，对它的基本操作已经算挺熟练了。” 我之前的想法和你们一样，直到最近我使用xhr时踩了不少坑儿，我才突然发现其实自己并不够了解xhr，我知道的只是最最基本的使用。</p>
<p>于是我决定好好地研究一番xhr的真面目，可拜读了不少博客后都不甚满意，于是我决定认真阅读一遍W3C的XMLHttpRequest标准。看完标准后我如同醍醐灌顶一般，感觉到了从未有过的清澈。这篇文章就是参考W3C的XMLHttpRequest标准和结合一些实践验证总结而来的。</p>
<h2 id="AJAX和XMLHttpRequest"><a href="#AJAX和XMLHttpRequest" class="headerlink" title="AJAX和XMLHttpRequest"></a><code>AJAX</code>和<code>XMLHttpRequest</code></h2><p>我们通常将Ajax等同于XMLHttpRequest，但细究起来它们两个是属于不同维度的2个概念。</p>
<p>以下是我认为对Ajax较为准确的解释：（摘自what is Ajax）<br>AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script.</p>
<p>AJAX is based on the following open standards:</p>
<p>Browser-based presentation using HTML and Cascading Style Sheets (CSS).</p>
<p>Data is stored in XML format and fetched from the server.</p>
<p>Behind-the-scenes data fetches using XMLHttpRequest objects in the browser.</p>
<p>JavaScript to make everything happen.</p>
<p>从上面的解释中可以知道：ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。</p>
<p>所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。</p>
<p>XMLHttpRequest的发展历程<br>XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。<br>XMLHttpRequest Level 1主要存在以下缺点：</p>
<p>受同源策略的限制，不能发送跨域请求；</p>
<p>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</p>
<p>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</p>
<p>那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能：</p>
<p>可以发送跨域请求，在服务端允许的情况下；</p>
<p>支持发送和接收二进制数据；</p>
<p>新增formData对象，支持发送表单数据；</p>
<p>发送和获取数据时，可以获取进度信息；</p>
<p>可以设置请求的超时时间；</p>
<p>当然更详细的对比介绍，可以参考阮老师的这篇文章，文章中对新增的功能都有具体代码示例。</p>
<p>XMLHttpRequest兼容性<br>关于xhr的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果XMLHttpRequest兼容性，下面提供一个截图。</p>
<p><img src="https://image-static.segmentfault.com/174/902/1749021644-569b9fb8d3b4a_articlex" alt="XMLHttpRequest兼容性"></p>
<p>从图中可以看到：</p>
<p>IE8/IE9、Opera Mini 完全不支持xhr对象</p>
<p>IE10/IE11部分支持，不支持 xhr.responseType为json</p>
<p>部分浏览器不支持设置请求超时，即无法使用xhr.timeout</p>
<p>部分浏览器不支持xhr.responseType为blob</p>
<p>细说XMLHttpRequest如何使用<br>先来看一段使用XMLHttpRequest发送Ajax请求的简单示例代码。</p>
<p>function sendAjax() {<br>  //构造表单数据<br>  var formData = new FormData();<br>  formData.append(‘username’, ‘johndoe’);<br>  formData.append(‘id’, 123456);<br>  //创建xhr对象<br>  var xhr = new XMLHttpRequest();<br>  //设置xhr请求的超时时间<br>  xhr.timeout = 3000;<br>  //设置响应返回的数据格式<br>  xhr.responseType = “text”;<br>  //创建一个 post 请求，采用异步<br>  xhr.open(‘POST’, ‘/server’, true);<br>  //注册相关事件回调处理函数<br>  xhr.onload = function(e) {<br>    if(this.status == 200||this.status == 304){<br>        alert(this.responseText);<br>    }<br>  };<br>  xhr.ontimeout = function(e) { … };<br>  xhr.onerror = function(e) { … };<br>  xhr.upload.onprogress = function(e) { … };</p>
<p>  //发送数据<br>  xhr.send(formData);<br>}<br>上面是一个使用xhr发送表单数据的示例，整个流程可以参考注释。</p>
<p>接下来我将站在使用者的角度，以问题的形式介绍xhr的基本使用。<br>我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。</p>
<p>如何设置request header<br>在发送Ajax请求（实质是一个HTTP请求）时，我们可能需要设置一些请求头部信息，比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。</p>
<p>void setRequestHeader(DOMString header, DOMString value);</p>
<p>注意点：</p>
<p>方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type;</p>
<p>Content-Type的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节；</p>
<p>setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错；</p>
<p>setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。下面是一个示例代码：</p>
<p>var client = new XMLHttpRequest();<br>client.open(‘GET’, ‘demo.cgi’);<br>client.setRequestHeader(‘X-Test’, ‘one’);<br>client.setRequestHeader(‘X-Test’, ‘two’);<br>// 最终request header中”X-Test”为: one, two<br>client.send();<br>如何获取response header<br>xhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，getResponseHeader(header)的header参数不区分大小写。</p>
<p>DOMString getAllResponseHeaders();<br>DOMString getResponseHeader(DOMString header);</p>
<p>这2个方法看起来简单，但却处处是坑儿。</p>
<p>你是否遇到过下面的坑儿?——反正我是遇到了。。。</p>
<p>使用getAllResponseHeaders()看到的所有response header与实际在控制台 Network 中看到的 response header 不一样</p>
<p>使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header “XXX”</p>
<p>经过一番寻找最终在 Stack Overflow找到了答案。</p>
<p>原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2这2个字段，无论是同域还是跨域请求；</p>
<p>原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” （两个名词的解释见下方）。</p>
<p>“simple response header”包括的 header 字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;<br>“Access-Control-Expose-Headers”：首先得注意是”Access-Control-Expose-Headers”进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。</p>
<p>所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。</p>
<p>如何指定xhr.response的数据类型<br>有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？<br>有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。</p>
<p>xhr.overrideMimeType()<br>overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type，这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType(‘text/xml; charset = utf-8’)来实现。</p>
<p>再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。</p>
<p>下面是一个获取图片文件的代码示例：</p>
<p>var xhr = new XMLHttpRequest();<br>//向 server 端获取一张图片<br>xhr.open(‘GET’, ‘/path/to/image.png’, true);</p>
<p>// 这行是关键！<br>//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集<br>xhr.overrideMimeType(‘text/plain; charset=x-user-defined’);</p>
<p>xhr.onreadystatechange = function(e) {<br>  if (this.readyState == 4 &amp;&amp; this.status == 200) {<br>    //通过 responseText 来获取图片文件对应的二进制字符串<br>    var binStr = this.responseText;<br>    //然后自己再想方法将逐个字节还原为二进制数据<br>    for (var i = 0, len = binStr.length; i &lt; len; ++i) {<br>      var c = binStr.charCodeAt(i);<br>      //String.fromCharCode(c &amp; 0xff);<br>      var byte = c &amp; 0xff;<br>    }<br>  }<br>};</p>
<p>xhr.send();<br>代码示例中xhr请求的是一张图片，通过将 response 的 content-type 改为’text/plain; charset=x-user-defined’，使得 xhr 以纯文本格式来解析接收到的blob 数据，最终用户通过this.responseText拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。</p>
<p>xhr.responseType<br>responseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可以参考本文的【XMLHttpRequest的兼容性】这一小节。那么responseType可以设置为哪些格式呢，我简单做了一个表，如下：</p>
<p>值    xhr.response 数据类型    说明<br>“”    String字符串    默认值(在不设置responseType时)<br>“text”    String字符串<br>“document”    Document对象    希望返回 XML 格式数据时使用<br>“json”    javascript 对象    存在兼容性问题，IE10/IE11不支持<br>“blob”    Blob对象<br>“arrayBuffer”    ArrayBuffer对象<br>下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.open(‘GET’, ‘/path/to/image.png’, true);<br>//可以将<code>xhr.responseType</code>设置为<code>&quot;blob&quot;</code>也可以设置为<code>&quot; arrayBuffer&quot;</code><br>//xhr.responseType = ‘arrayBuffer’;<br>xhr.responseType = ‘blob’;</p>
<p>xhr.onload = function(e) {<br>  if (this.status == 200) {<br>    var blob = this.response;<br>    …<br>  }<br>};</p>
<p>xhr.send();<br>小结<br>虽然在xhr level 2中，2者是共同存在的。但其实不难发现，xhr.responseType就是用来取代xhr.overrideMimeType()的，xhr.responseType功能强大的多，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。</p>
<p>如何获取response数据<br>xhr提供了3个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML</p>
<p>xhr.response</p>
<p>默认值：空字符串””</p>
<p>当请求完成时，此属性才有正确的值</p>
<p>请求未完成时，此属性的值可能是””或者 null，具体与 xhr.responseType有关：当responseType为””或”text”时，值为””；responseType为其他值时，值为 null</p>
<p>xhr.responseText</p>
<p>默认值为空字符串””</p>
<p>只有当 responseType 为”text”、””时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错</p>
<p>只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串””：请求未完成、请求失败</p>
<p>xhr.responseXML</p>
<p>默认值为 null</p>
<p>只有当 responseType 为”text”、””、”document”时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错</p>
<p>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</p>
<p>如何追踪ajax请求的当前状态<br>在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？</p>
<p>用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。</p>
<p>  xhr.onreadystatechange = function () {<br>    switch(xhr.readyState){<br>      case 1://OPENED<br>        //do something<br>            break;<br>      case 2://HEADERS_RECEIVED<br>        //do something<br>        break;<br>      case 3://LOADING<br>        //do something<br>        break;<br>      case 4://DONE<br>        //do something<br>        break;<br>    }<br>值    状态    描述<br>0    UNSENT (初始状态，未打开)    此时xhr对象被成功构造，open()方法还未被调用<br>1    OPENED (已打开，未发送)    open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错<br>2    HEADERS_RECEIVED (已获取响应头)    send()方法已经被调用, 响应头和响应状态已经返回<br>3    LOADING (正在下载响应体)    响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据<br>4    DONE (整个数据传输过程结束)    整个数据传输过程结束，不管本次请求是成功还是失败<br>如何设置请求的超时时间<br>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。</p>
<p>xhr.timeout</p>
<p>单位：milliseconds 毫秒<br>默认值：0，即不设置超时</p>
<p>很多同学都知道：从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。</p>
<p>【那么到底什么时候才算是请求开始 ？】<br>——xhr.onloadstart事件触发的时候，也就是你调用xhr.send()方法的时候。<br>因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。</p>
<p>【那么什么时候才算是请求结束 ？】<br>—— xhr.loadend事件触发的时候。</p>
<p>另外，还有2个需要注意的坑儿：</p>
<p>可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。</p>
<p>当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。</p>
<p>如何发一个同步请求<br>xhr默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由xhr.open（）传入的async参数决定。</p>
<p>open(method, url [, async = true [, username = null [, password = null]]])</p>
<p>method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写</p>
<p>url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如<a href="http://www.example.com/example.php" target="_blank" rel="noopener">http://www.example.com/example.php</a></p>
<p>async: 默认值为true，即为异步请求，若async=false，则为同步请求</p>
<p>在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。</p>
<p>W3C 的 xhr标准中关于open()方法有这样一段说明：</p>
<p>Throws an “InvalidAccessError” exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string.</p>
<p>从上面一段说明可以知道，当xhr为同步请求时，有如下限制：</p>
<p>xhr.timeout必须为0</p>
<p>xhr.withCredentials必须为 false</p>
<p>xhr.responseType必须为””（注意置为”text”也不允许）</p>
<p>若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。</p>
<p>之前说过页面中应该尽量避免使用sync同步请求，为什么呢？<br>因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。</p>
<p>另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。</p>
<p>如何获取上传、下载的进度<br>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。<br>我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件：</p>
<p>上传触发的是xhr.upload对象的 onprogress事件</p>
<p>下载触发的是xhr对象的onprogress事件</p>
<p>xhr.onprogress = updateProgress;<br>xhr.upload.onprogress = updateProgress;<br>function updateProgress(event) {<br>    if (event.lengthComputable) {<br>      var completedPercent = event.loaded / event.total;<br>    }<br> }<br>可以发送什么类型的数据<br>void send(data);</p>
<p>xhr.send(data)的参数data可以是以下几种类型：</p>
<p>ArrayBuffer</p>
<p>Blob</p>
<p>Document</p>
<p>DOMString</p>
<p>FormData</p>
<p>null</p>
<p>如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使你真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null.</p>
<p>xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值：</p>
<p>如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8；</p>
<p>如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8；</p>
<p>如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx]</p>
<p>如果data是其他类型，则不会设置content-type的默认值</p>
<p>当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。</p>
<p>另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute ‘send’ on ‘XMLHttpRequest’。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。</p>
<p>try{<br>    xhr.send(data)<br>  }catch(e) {<br>    //doSomething…<br>  };<br>xhr.withCredentials与 CORS 什么关系<br>我们都知道，在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。</p>
<p>造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（credentials）如”cookies”和”HTTP authentication schemes”。除非xhr.withCredentials为true（xhr对象有一个属性叫withCredentials，默认值为false）。</p>
<p>所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。</p>
<p>另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，而必须设置为请求页面的域名。</p>
<p>xhr相关事件<br>事件分类<br>xhr相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是XMLHttpRequest的部分实现代码：</p>
<p>interface XMLHttpRequestEventTarget : EventTarget {<br>  // event handlers<br>  attribute EventHandler onloadstart;<br>  attribute EventHandler onprogress;<br>  attribute EventHandler onabort;<br>  attribute EventHandler onerror;<br>  attribute EventHandler onload;<br>  attribute EventHandler ontimeout;<br>  attribute EventHandler onloadend;<br>};</p>
<p>interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {</p>
<p>};</p>
<p>interface XMLHttpRequest : XMLHttpRequestEventTarget {<br>  // event handler<br>  attribute EventHandler onreadystatechange;<br>  readonly attribute XMLHttpRequestUpload upload;<br>};<br>从代码中我们可以看出：</p>
<p>XMLHttpRequestEventTarget接口定义了7个事件：</p>
<p>onloadstart</p>
<p>onprogress</p>
<p>onabort</p>
<p>ontimeout</p>
<p>onerror</p>
<p>onload</p>
<p>onloadend</p>
<p>每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象</p>
<p>XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件</p>
<p>onreadystatechange是XMLHttpRequest独有的事件</p>
<p>所以这么一看就很清晰了：<br>xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。</p>
<p>事件触发条件<br>下面是我自己整理的一张xhr相关事件触发条件表，其中最需要注意的是 onerror 事件的触发条件。</p>
<p>事件    触发条件<br>onreadystatechange    每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。<br>onloadstart    调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。<br>onprogress    xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。<br>onload    当请求成功完成时触发，此时xhr.readystate=4<br>onloadend    当请求结束（包括请求成功和请求失败）时触发<br>onabort    当调用xhr.abort()后触发<br>ontimeout    xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。<br>onerror    在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。<br>事件触发顺序<br>当请求一切正常时，相关的事件触发顺序如下：</p>
<p>触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次)</p>
<p>触发xhr.onloadstart<br>//上传阶段开始：</p>
<p>触发xhr.upload.onloadstart</p>
<p>触发xhr.upload.onprogress</p>
<p>触发xhr.upload.onload</p>
<p>触发xhr.upload.onloadend<br>//上传结束，下载阶段开始：</p>
<p>触发xhr.onprogress</p>
<p>触发xhr.onload</p>
<p>触发xhr.onloadend</p>
<p>发生abort/timeout/error异常的处理<br>在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下：</p>
<p>一旦发生abort或timeout或error异常，先立即中止当前请求</p>
<p>将 readystate 置为4，并触发 xhr.onreadystatechange事件</p>
<p>如果上传阶段还没有结束，则依次触发以下事件：</p>
<p>xhr.upload.onprogress</p>
<p>xhr.upload.[onabort或ontimeout或onerror]</p>
<p>xhr.upload.onloadend</p>
<p>触发 xhr.onprogress事件</p>
<p>触发 xhr.[onabort或ontimeout或onerror]事件</p>
<p>触发xhr.onloadend 事件</p>
<p>在哪个xhr事件中注册成功回调？<br>从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。</p>
<p>xhr.onload = function () {<br>    //如果请求成功<br>    if(xhr.status == 200){<br>      //do successCallback<br>    }<br>  }<br>上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。</p>
<p>  xhr.onload = function () {<br>    //如果请求成功<br>    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){<br>      //do successCallback<br>    }<br>  }<br>结语<br>终于写完了……<br>看完那一篇长长的W3C的xhr 标准，我眼睛都花了……<br>希望这篇总结能帮助刚开始接触XMLHttpRequest的你。</p>
<p>最后给点扩展学习资料，如果你：</p>
<p>想真正搞懂XMLHttpRequest，最靠谱的方法还是看 W3C的xhr 标准;</p>
<p>想结合代码学习如何用XMLHttpRequest发各种类型的数据，可以参考html5rocks上的这篇文章</p>
<p>想粗略的了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍；</p>
<p>想了解XMLHttpRequest 的发展历程，可以参考阮老师的文章；</p>
<p>想了解Ajax的基本介绍，可以参考AJAX Tutorial;</p>
<p>想了解跨域请求，则可以参考W3C的 cors 标准;</p>
<p>想了解http协议，则可以参考HTTP Tutorial;</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/XHR/" rel="tag"># XHR</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/25/聊聊cookie-转/" rel="next" title="聊聊cookie(转)">
                <i class="fa fa-chevron-left"></i> 聊聊cookie(转)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/25/跨域传递cookie-转/" rel="prev" title="跨域传递cookie(转)">
                跨域传递cookie(转) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">沙雕爹爹</p>
              <p class="site-description motion-element" itemprop="description">Personal tech blog.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#AJAX和XMLHttpRequest"><span class="nav-number">1.</span> <span class="nav-text">AJAX和XMLHttpRequest</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沙雕爹爹</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
