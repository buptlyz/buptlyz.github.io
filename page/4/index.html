<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Personal tech blog.">
<meta name="keywords" content="Github Page Hexo">
<meta property="og:type" content="website">
<meta property="og:title" content="沙雕爹爹">
<meta property="og:url" content="https://buptlyz.github.io/page/4/index.html">
<meta property="og:site_name" content="沙雕爹爹">
<meta property="og:description" content="Personal tech blog.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="沙雕爹爹">
<meta name="twitter:description" content="Personal tech blog.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://buptlyz.github.io/page/4/">





  <title>沙雕爹爹</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">沙雕爹爹</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay foolish, stay humble.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/如何用js实现“高亮划词”的在线笔记功能-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/如何用js实现“高亮划词”的在线笔记功能-转/" itemprop="url">如何用js实现“高亮划词”的在线笔记功能(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T19:19:30+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://segmentfault.com/a/1190000018981813" target="_blank" rel="noopener">原文链接</a></p>
<p>需要解决的核心问题：</p>
<ul>
<li>加高亮背景。即如何根据用户在网页上的选取，为响应的文本添加高亮背景</li>
<li>高亮区域的持久化与还原。即如何保存用户高亮信息，并在下次浏览时准确还原。</li>
</ul>
<h2 id="如何加高亮背景"><a href="#如何加高亮背景" class="headerlink" title="如何加高亮背景"></a>如何加高亮背景</h2><p>基本思路如下：</p>
<ol>
<li>获取选中的文本节点：通过用户选择的区域信息，获取所有被选中的所有文本节点</li>
<li>为文本节点添加背景色：给这些文本节点包裹一层新的元素，该元素具有指定的背景颜色。</li>
</ol>
<h3 id="如何获取选中的文本节点？"><a href="#如何获取选中的文本节点？" class="headerlink" title="如何获取选中的文本节点？"></a>如何获取选中的文本节点？</h3><h4 id="Selection-API"><a href="#Selection-API" class="headerlink" title="Selection API"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a></h4><p>兼容性还不错，如果需要支持更低版本，需要polyfill。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/20/16a3b78be942a10d?w=2354&amp;h=858&amp;f=png&amp;s=216507" alt="Selection API"></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a>可以返回一系列关于用户选区的信息。那么是不是可以通过它直接获取选取中的所有DOM元素呢？</p>
<p>很遗憾并不能。但好在它可以返回选区但首尾节点信息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> range = <span class="built_in">window</span>.getSelection().getRangeAt(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> start = &#123;</span><br><span class="line">  node: range.startContainer,</span><br><span class="line">  offset: range.startOffset</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> end = &#123;</span><br><span class="line">  node: range.endContainer,</span><br><span class="line">  offset: range.endOffset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Range</code>对象包含了选区但开始与结束信息，其中包括节点(node)与文本偏移量(offset)。节点信息不用多说，这里解释一下<code>offset</code>是指什么：例如，标签<code>&lt;p&gt;This is a paragraph.&lt;/p&gt;</code>，用户选取但部分是<code>a paragraph</code>这两个词，这是首尾的<code>node</code>均为<code>p</code>元素内的文本节点(<code>Text Node</code>)，而<code>startOffset</code>和<code>endOffset</code>分别为<code>2</code>和<code>6</code>。</p>
<blockquote>
<p>为了获取用户当前选中的文本，可以使用<code>Window.getSelection()</code>或者<code>Document.getSelection()</code>方法。它们返回一个[<code>Selection</code>][]对象，你可以用一个变量存储它。<br>你可以对你存储的<code>selection</code>执行很多操作，如调用<code>Selection.toString()</code>方法拷贝一份文本字符串，或者使用<code>Selection.addRange()</code>/<code>Selection.removeRange()</code>给这个<code>selection</code>添加/删除一个范围(正如标准<code>Rnage</code>对象展示的)，又或者使用<code>Selection.selectAllChildren()</code>修改<code>selection</code>为这个DOM节点的全部内容。<br>当<code>selection</code>有变化，或者新的<code>selection</code>被创建时，使用<code>GlobalEventHandlers.onselectionchange</code>和<code>GlobalEventHandlers.onselectstart</code>事件处理函数里可以执行你的代码。</p>
</blockquote>
<h4 id="首尾文本节点拆分"><a href="#首尾文本节点拆分" class="headerlink" title="首尾文本节点拆分"></a>首尾文本节点拆分</h4><p>理解了<code>offset</code>的概念后，自然就会发现有个问题需要解决。由于用户选区(<code>selection</code>)可能只包含一个文本节点的一部分(即<code>offset</code>不为0)，所以我们最后得到的用户选区所包含的节点里，也只希望有首尾文本节点的这一部分。对此，我们可以使用<code>.splitText()</code>拆分文本节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首节点</span></span><br><span class="line"><span class="keyword">if</span> (curNode === $startNode) &#123;</span><br><span class="line">  <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">    curNode.splitText(startOffset);</span><br><span class="line">    <span class="keyword">const</span> node = curNode.nextSibling;</span><br><span class="line">    selectedNodes.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾节点</span></span><br><span class="line"><span class="keyword">if</span> (curNode === $endNode) &#123;</span><br><span class="line">  <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = curNode;</span><br><span class="line">    node.splitText(endOffset);</span><br><span class="line">    selectedNodes.push(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会依据<code>offset</code>对文本节点进行拆分。对于开始节点，只需要收集它的后半部分；而对于结束节点则是前半部分。</p>
<h4 id="遍历DOM树"><a href="#遍历DOM树" class="headerlink" title="遍历DOM树"></a>遍历DOM树</h4><p>到目前为止，我们准确找到了首尾节点，所以下一步就是找出“中间”所有的文本节点。这就需要遍历DOM树。</p>
<p>“中间”加上引号是因为，在视觉上，这些节点是位于首尾之间的，但由于DOM不是线性结构而是树形结构，所以这个“中间”换成程序语言，就是指深度优先遍历时，位于首尾节点之间的所有文本节点。DFS的方法有很多，可以递归，也可以用栈+循环，这里就不赘述了。</p>
<p>需要提一下的是，由于我们是要为文本节点添加高亮背景，因此在遍历时只会收集文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">  selectedNodes.push(curNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何为文本节点添加背景色？"><a href="#如何为文本节点添加背景色？" class="headerlink" title="如何为文本节点添加背景色？"></a>如何为文本节点添加背景色？</h3><p>一个最直接的方法就是为选中的文本节点(包括分拆后的首尾节点)“包裹上”一个带背景样式的元素。</p>
<p>具体的，我们可以给每个文本节点加上一个<code>class</code>为<code>highlight</code>的<code>span</code>元素；而背景样式则通过<code>.highlight</code>选择器设置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用上面封装的方法</span></span><br><span class="line"><span class="keyword">const</span> nodes = getSelectedNodes(start, end);</span><br><span class="line"></span><br><span class="line">nodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wrap = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">  wrap.setAttribute(<span class="string">'class'</span>, <span class="string">'highlight'</span>);</span><br><span class="line">  wrap.appendChild(node.cloneNode(<span class="literal">false</span>));</span><br><span class="line">  node.parentNode.replaceChild(wrap);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>p.s.</strong> 选区的重合问题</p>
<p>举个例子：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/20/16a3b62dd95bac60?w=1195&amp;h=720&amp;f=gif&amp;s=881043" alt="选区的重合问题"></p>
<p>具体解决后面再说。</p>
<h2 id="如何实现高亮选取的持久化与还原？"><a href="#如何实现高亮选取的持久化与还原？" class="headerlink" title="如何实现高亮选取的持久化与还原？"></a>如何实现高亮选取的持久化与还原？</h2><blockquote>
<p>持久化高亮选区的核心是找到一种合适的DOM节点序列化方法。</p>
</blockquote>
<p>通过第三部分可以知道，当确定了首尾节点与文本偏移（offset）信息后，即可为其间文本节点添加背景色。其中，offset 是数值类型，要在服务器保存它自然没有问题；但是 DOM 节点不同，在浏览器中保存它只需要赋值给一个变量，但想在后端保存所谓的 DOM 则不那么直接了。</p>
<h3 id="序列化DOM节点知识"><a href="#序列化DOM节点知识" class="headerlink" title="序列化DOM节点知识"></a>序列化DOM节点知识</h3><p>所以这里的核心点就是找到一种方法，能够定位DOM节点，同时可以被保存成普通的<code>JSON</code>，用以传给后端保存，这个过程在本文中被称为DOM标识的“序列化”。而下次用户访问时，又可以从后端取回，然后“反序列化”为对应的DOM节点。</p>
<p>有几种常见的方式来标识DOM节点：</p>
<ul>
<li>使用<code>xPath</code></li>
<li>使用<code>CSS Selector</code>语法</li>
<li>使用<code>tagName + index</code></li>
</ul>
<p>这里选择第三种方法。</p>
<p>需要注意的一点，我们通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a>取到的首尾节点一般是文本节点，而这里要记录的<code>tagName</code>和<code>index</code>都是该文本节点的父元素节点(<code>Element Node</code>)的，而<code>childIndex</code>表示该文本节点是其父节点的第几个子节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serialize = <span class="function">(<span class="params">textNode, root = <span class="built_in">document</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = textNode.parentElement;</span><br><span class="line">  <span class="keyword">let</span> childIndex = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = node.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (textNode === node.childNodes[i]) &#123;</span><br><span class="line">      childIndex = i;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> tagName = node.tagName;</span><br><span class="line">  <span class="keyword">const</span> list = root.getElementsByTagName(tagName);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>, len = list.length; index &lt; len; index++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === list[index]) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;tagName, index, childIndex&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;tagName, <span class="attr">index</span>: <span class="number">-1</span>, childIndex&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该方法返回的信息，再加上<code>offset</code>的信息，即定位选取的起始位置，同时也完全可以发送给后端进行保存了。</p>
<h3 id="反序列化DOM节点"><a href="#反序列化DOM节点" class="headerlink" title="反序列化DOM节点"></a>反序列化DOM节点</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deSerialize = <span class="function">(<span class="params">meta, root = <span class="built_in">document</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;tagName, index, childIndex&#125; = meta;</span><br><span class="line">  <span class="keyword">const</span> parent = root.getElementsByTagName(tagName)[index];</span><br><span class="line">  <span class="keyword">return</span> parent.childNodes[childIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经解决了两个核心问题，这似乎已经是一个可用版本了。但<strong>其实不然</strong>，根据实践经验，如果仅仅是上面这些处理，往往是无法应对实际需求的，存在一些“致命问题”。</p>
<h2 id="如何实现一个生产环境可用的“划词高亮”？"><a href="#如何实现一个生产环境可用的“划词高亮”？" class="headerlink" title="如何实现一个生产环境可用的“划词高亮”？"></a>如何实现一个生产环境可用的“划词高亮”？</h2><h3 id="上面的方案有什么问题？"><a href="#上面的方案有什么问题？" class="headerlink" title="上面的方案有什么问题？"></a>上面的方案有什么问题？</h3><p>首先来看看上面的方案会有什么问题。</p>
<p>当我们需要高亮文本时，会为文本节点包裹<code>span</code>元素，这就改动了页面的 DOM 结构。它可能会导致后续高亮的首尾节点与其 <code>offset</code> 信息其实是基于被改动后的 DOM 结构的。带来的结果有两个：</p>
<ul>
<li>下次访问时，程序必须按上次用户高亮的顺序还原。</li>
<li>用户不能随意取消（删除）高亮区域，只能按添加顺序从后往前删。</li>
</ul>
<p>否则，就会有部分的高亮选区在还原时无法定位到正确的元素。</p>
<p>文字可能不好理解，下面我举个例子来直观解释下这个问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常高兴今天能够在这里和大家分享一下文本高亮（在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于上面这段 HTML，用户分别按顺序高亮了两个部分：“高兴”和“文本高亮”。那么按照上面的实现方式，这段 HTML 变成了下面这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高兴<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    今天能够在这里和大家分享一下</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>文本高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    （在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对应的两个序列化数据分别为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// “高兴”两个字被高亮时获取的序列化信息</span></span><br><span class="line">&#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">0</span>,</span><br><span class="line">        offset: <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">0</span>,</span><br><span class="line">        offset: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “文本高亮”四个字被高亮时获取的序列化信息。</span></span><br><span class="line"><span class="comment">// 这时候由于p下面已经存在了一个高亮信息（即“高兴”）。</span></span><br><span class="line"><span class="comment">// 所以其内部 HTML 结构已被修改，直观来说就是 childNodes 改变了。</span></span><br><span class="line"><span class="comment">// 进而，childIndex属性由于前一个 span 元素的加入，变为了 2。</span></span><br><span class="line">&#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">2</span>,</span><br><span class="line">        offset: <span class="number">14</span></span><br><span class="line">    &#125;,</span><br><span class="line">    end: &#123;</span><br><span class="line">        tagName: <span class="string">'p'</span>,</span><br><span class="line">        index: <span class="number">0</span>,</span><br><span class="line">        childIndex: <span class="number">2</span>,</span><br><span class="line">        offset: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，“文本高亮”这四个字的首尾节点的 <code>childIndex</code> 都被记为 2，这是由于前一个高亮区域改变了<code>p</code>元素下的DOM结构。如果此时“高兴”选区的高亮被用户取消，那么下次再访问页面就无法还原高亮了 —— “高兴”选区的高亮被取消了，<code>p</code>下自然就不会出现第三个 <code>childNode</code>，那么 <code>childIndex</code> 为 2 就找不到对应的节点了。这就导致存储的数据在还原高亮选区时出现问题。</p>
<p>此外，还记得在第三部分末尾提到的高亮选取重合问题么？支持选取重合很容易出现如下的包裹元素嵌套情况：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高兴<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    今天能够在这里和大家分享一下</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span></span><br><span class="line">        文本</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    （在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这也使得某个文本区域经过多次高亮、取消高亮后，会出现与原 HTML 页面不同的复杂嵌套结构。可以预见，当我们使用 <code>xpath</code> 或 <code>CSS selector</code> 作为 DOM 标识时，上面提到的问题也会出现，同时也使其他需求的实现更加复杂。</p>
<p>到这里可以提一下其他开源库或产品是如何处理选区重合问题的：</p>
<ul>
<li>开源库 <a href="https://github.com/timdown/rangy" target="_blank" rel="noopener">Rangy</a> 有一个 <code>Highlighter</code> 模块可以实现文本高亮，但其对于选区重合的情况是将两个选区直接合并了，这是不合符我们业务需求的。</li>
<li>付费产品 <a href="https://chrome.google.com/webstore/detail/pnhplgjpclknigjpccbcnmicgcieojbh" target="_blank" rel="noopener">Diigo</a> 直接不允许选区的重合。</li>
<li><a href="https://medium.com/" target="_blank" rel="noopener">Medium.com</a> 是支持选区重合的，体验非常不错，这也是我们产品的目标。但它页面的内容区结构相较我面对的情况会更简单与更可控。</li>
</ul>
<p>所以如何解决这些问题呢？</p>
<h3 id="另一种序列化-反序列化方式"><a href="#另一种序列化-反序列化方式" class="headerlink" title="另一种序列化/反序列化方式"></a>另一种序列化/反序列化方式</h3><p>我会对第四部分提到的序列化方式进行改进。仍然记录文本节点的父节点 <code>tagName</code> 与 <code>index</code>，但不再记录文本节点在 <code>childNodes</code> 中的 <code>index</code> 与 <code>offset</code>，而是记录开始（结束）位置在整个父元素节点中的文本偏移量。</p>
<p>例如下面这段 HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    非常</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>高兴<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    今天能够在这里和大家分享一下</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"highlight"</span>&gt;</span>文本高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    （在线笔记）的实现方式。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于“文本高亮”这个高亮选区，之前用于标识文本起始位置的信息为<code>childIndex = 2</code>，<code>offset = 14</code>。而现在变为<code>offset = 18</code>（从<code>p</code>元素下第一个文本“非”开始计算，经过18个字符后是“文”）。可以看出，这样表示的优点是，不管<code>p</code>内部原有的文本节点被<code>span</code>（包裹）节点如何分割，都不会影响高亮选区还原时的节点定位。</p>
<p>据此，在序列化时，我们需要一个方法来将文本节点内偏移量“翻译”为其对应的父节点内部的总体文本偏移量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTextPreOffset</span>(<span class="params">root, text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodeStack = [root];</span><br><span class="line">    <span class="keyword">let</span> curNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode = nodeStack.pop()) &#123;</span><br><span class="line">        <span class="keyword">const</span> children = curNode.childNodes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = children.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            nodeStack.push(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span> &amp;&amp; curNode !== text) &#123;</span><br><span class="line">            offset += curNode.textContent.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而还原高亮选区时，需要一个对应的逆过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTextChildByOffset</span>(<span class="params">parent, offset</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nodeStack = [parent];</span><br><span class="line">    <span class="keyword">let</span> curNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> startOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode = nodeStack.pop()) &#123;</span><br><span class="line">        <span class="keyword">const</span> children = curNode.childNodes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = children.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            nodeStack.push(children[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curNode.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">            startOffset = offset - curOffset;</span><br><span class="line">            curOffset += curNode.textContent.length;</span><br><span class="line">            <span class="keyword">if</span> (curOffset &gt;= offset) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!curNode) &#123;</span><br><span class="line">        curNode = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">node</span>: curNode, <span class="attr">offset</span>: startOffset&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="支持高亮选区的重合"><a href="#支持高亮选区的重合" class="headerlink" title="支持高亮选区的重合"></a>支持高亮选区的重合</h3><p>重合的高亮选区带来的一个问题就是高亮包裹元素的嵌套，从而使得 DOM 结构会有较复杂的变动，增加了其他功能（交互）实现与问题排查的复杂度。因此，我在前面提到的包裹高亮元素时，会再进行一些稍复杂的处理（尤其是重合选区），以保证尽量复用已有的包裹元素，避免元素的嵌套。</p>
<p>在处理时，将需要包裹的各个文本片段(<code>Text Node</code>)分为三类情况：</p>
<ol>
<li>完全未被包裹，则直接包裹该部分。</li>
<li>属于被包裹过的文本节点的一部分，则使用<code>.splitText()</code>将其拆分。</li>
<li>是一段完全被包裹的文本段，不需要对节点进行处理。</li>
</ol>
<p>与此同时，为每个选区生成唯一 ID，将该段文本几点多对应的 ID、以及其由于选区重合所涉及到的其他 ID，都附加包裹元素上。因此像上面的第三种情况，不需要变更 DOM 结构，只用更新包裹元素两类 ID 所对应的 <code>dataset</code> 属性即可。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>解决以上的一些问题后，“文本划词高亮”就基本可用了。还剩下一些“小修补”，简单提一下。</p>
<h3 id="高亮选区的交互事件，例如-click、hover"><a href="#高亮选区的交互事件，例如-click、hover" class="headerlink" title="高亮选区的交互事件，例如 click、hover"></a>高亮选区的交互事件，例如 <code>click</code>、<code>hover</code></h3><p>首先，可以为每个高亮选区生成一个唯一 ID，然后在该选区内所有的包裹元素上记录该 ID 信息，例如用<code>data-highlight-id</code>属性。而对于选取重合的部分可以在<code>data-highlight-extra-id</code>属性中记录重合的其他选区的 ID。</p>
<p>而监听到包裹元素的 <code>click</code>、<code>hover</code> 后，则触发 <code>highlighter</code> 的相应事件，并带上高亮 ID。</p>
<h3 id="取消高亮（高亮背景的删除）"><a href="#取消高亮（高亮背景的删除）" class="headerlink" title="取消高亮（高亮背景的删除）"></a>取消高亮（高亮背景的删除）</h3><p>由于在包裹时支持选区重合（对应会有上面提到的三种情况需要处理），因此，在删除选取高亮时，也会有三种情况需要分别处理：</p>
<ul>
<li>直接删除包裹元素。即不存在选区重合。</li>
<li>更新data-highlight-id属性和data-highlight-extra-id属性。即删除的高亮 ID 与 data-highlight-id 相同。</li>
<li>只更新data-highlight-extra-id属性。即删除的高亮 ID 只在 data-highlight-extra-id 中。</li>
</ul>
<h3 id="对于前端生成的动态页面怎么办？"><a href="#对于前端生成的动态页面怎么办？" class="headerlink" title="对于前端生成的动态页面怎么办？"></a>对于前端生成的动态页面怎么办？</h3><p>不难发现，这种非耦合的文本高亮功能很依赖于页面的 DOM 结构，需要保证做高亮时的 DOM 结构和还原时的一致，否则无法正确还原出选区的起始节点位置。据此，对“划词”高亮最友好的应该是纯后端渲染的页面，在<code>onload</code>监听中触发高亮选区还原的方法即可。但目前越来越多的页面（或页面的一部分）是前端动态生成的，针对这个问题该怎么处理呢？</p>
<p>我在实际工作中也遇到了类似问题 —— 页面的很多区域是 ajax 请求后前端渲染的。我的处理方式包括如下：</p>
<ul>
<li>隔离变化范围。将上述代码中的“根节点”从<code>documentElement</code>换为另一个更具体的容器元素。例如我面对的业务会在 id 为 <code>article-container</code> 的<code>div</code>内加载动态内容，那么我就会指定这个 <code>article-container</code> 为“根节点”。这样可以最大程度防止外部的 DOM 变动影响到高亮位置的定位，尤其是页面改版。</li>
<li>确定高亮选区的还原时机。由于内容可能是动态生成，所以需要等到该部分的 DOM 渲染完成后再调用还原方法。如果有暴露的监听事件可以在监听内处理；或者通过 <code>MutationObserver</code> 监听标志性元素来判断该部分是否加载完成。</li>
<li>记录业务内容信息，应对内容区改版。内容区的 DOM 结构更改算是“毁灭性打击”。如何确实有该类情况，可以尝试让业务内容展示方将段落信息等具体的内容信息绑定在 DOM 元素上，而我在高亮时取出这些信息来冗余存储，改版后可以通过这些内容信息“刷”一遍存储的数据。</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>篇幅问题，还有其他细节的问题就不在这篇文章里分享了。详细内容可以参考 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">web-highlighter</a> 这个仓库里的实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先从“划词高亮”功能的两个核心问题（如何高亮用户选区的文本、如何将高亮选区还原）切入，基于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Selection_API" target="_blank" rel="noopener"><code>Selection API</code></a>、深度优先遍历和 DOM 节点标识的序列化这些手段实现了“划词高亮”的核心功能。然而，该方案仍然存在一些实际问题，因此在第 5 部分进一步给出了相应的解决方案。</p>
<p>基于实际开发的经验，我发现解决上述几个“划词高亮”核心问题的代码具有一定通用性，因此把核心部分的源码封装成了独立的库 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">web-highlighter</a>，托管在 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">github</a>，也可以通过 <code>npm</code> 安装。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/21/16a3f9a22e744782?w=1916&amp;h=514&amp;f=png&amp;s=142468" alt="web-highlighter"></p>
<p>其已服务于线上产品业务，基本的高亮功能一行代码即可开启：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Highlighter()).run();</span><br></pre></td></tr></table></figure>
<p>兼容IE 10/11、Edge、Firefox 52+、Chrome 15+、Safari 5.1+、Opera 15+。</p>
<p>感兴趣的小伙伴可以 <a href="https://github.com/alienzhou/web-highlighter" target="_blank" rel="noopener">star</a> 一下。感谢支持，欢迎交流 😊</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/JS异步捕获二三事-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/JS异步捕获二三事-转/" itemprop="url">JS异步捕获二三事(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T18:23:25+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://segmentfault.com/a/1190000018985956" target="_blank" rel="noopener">原文链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/跨域资源共享-CORS-详解-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/跨域资源共享-CORS-详解-转/" itemprop="url">跨域资源共享 CORS 详解(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T15:30:29+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">原文链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/跨域cookie同步方案-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/跨域cookie同步方案-转/" itemprop="url">跨域cookie同步方案(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T15:14:00+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://singleant.iteye.com/blog/1505284" target="_blank" rel="noopener">原文链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/跨域传递cookie-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/跨域传递cookie-转/" itemprop="url">跨域传递cookie(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T15:11:26+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/Honeymao/article/details/77855841" target="_blank" rel="noopener">原文链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/你真的会使用XMLHttpRequest吗？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/你真的会使用XMLHttpRequest吗？/" itemprop="url">你真的会使用XMLHttpRequest吗？(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T14:29:29+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://segmentfault.com/a/1190000004322487#articleHeader13" target="_blank" rel="noopener">原文链接</a></p>
<p>看到标题时，有些同学可能会想：“我已经用xhr成功地发过很多个Ajax请求了，对它的基本操作已经算挺熟练了。” 我之前的想法和你们一样，直到最近我使用xhr时踩了不少坑儿，我才突然发现其实自己并不够了解xhr，我知道的只是最最基本的使用。</p>
<p>于是我决定好好地研究一番xhr的真面目，可拜读了不少博客后都不甚满意，于是我决定认真阅读一遍W3C的XMLHttpRequest标准。看完标准后我如同醍醐灌顶一般，感觉到了从未有过的清澈。这篇文章就是参考W3C的XMLHttpRequest标准和结合一些实践验证总结而来的。</p>
<h2 id="AJAX和XMLHttpRequest"><a href="#AJAX和XMLHttpRequest" class="headerlink" title="AJAX和XMLHttpRequest"></a><code>AJAX</code>和<code>XMLHttpRequest</code></h2><p>我们通常将Ajax等同于XMLHttpRequest，但细究起来它们两个是属于不同维度的2个概念。</p>
<p>以下是我认为对Ajax较为准确的解释：（摘自what is Ajax）<br>AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script.</p>
<p>AJAX is based on the following open standards:</p>
<p>Browser-based presentation using HTML and Cascading Style Sheets (CSS).</p>
<p>Data is stored in XML format and fetched from the server.</p>
<p>Behind-the-scenes data fetches using XMLHttpRequest objects in the browser.</p>
<p>JavaScript to make everything happen.</p>
<p>从上面的解释中可以知道：ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。</p>
<p>所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。</p>
<p>XMLHttpRequest的发展历程<br>XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。<br>XMLHttpRequest Level 1主要存在以下缺点：</p>
<p>受同源策略的限制，不能发送跨域请求；</p>
<p>不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；</p>
<p>在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</p>
<p>那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能：</p>
<p>可以发送跨域请求，在服务端允许的情况下；</p>
<p>支持发送和接收二进制数据；</p>
<p>新增formData对象，支持发送表单数据；</p>
<p>发送和获取数据时，可以获取进度信息；</p>
<p>可以设置请求的超时时间；</p>
<p>当然更详细的对比介绍，可以参考阮老师的这篇文章，文章中对新增的功能都有具体代码示例。</p>
<p>XMLHttpRequest兼容性<br>关于xhr的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果XMLHttpRequest兼容性，下面提供一个截图。</p>
<p><img src="https://image-static.segmentfault.com/174/902/1749021644-569b9fb8d3b4a_articlex" alt="XMLHttpRequest兼容性"></p>
<p>从图中可以看到：</p>
<p>IE8/IE9、Opera Mini 完全不支持xhr对象</p>
<p>IE10/IE11部分支持，不支持 xhr.responseType为json</p>
<p>部分浏览器不支持设置请求超时，即无法使用xhr.timeout</p>
<p>部分浏览器不支持xhr.responseType为blob</p>
<p>细说XMLHttpRequest如何使用<br>先来看一段使用XMLHttpRequest发送Ajax请求的简单示例代码。</p>
<p>function sendAjax() {<br>  //构造表单数据<br>  var formData = new FormData();<br>  formData.append(‘username’, ‘johndoe’);<br>  formData.append(‘id’, 123456);<br>  //创建xhr对象<br>  var xhr = new XMLHttpRequest();<br>  //设置xhr请求的超时时间<br>  xhr.timeout = 3000;<br>  //设置响应返回的数据格式<br>  xhr.responseType = “text”;<br>  //创建一个 post 请求，采用异步<br>  xhr.open(‘POST’, ‘/server’, true);<br>  //注册相关事件回调处理函数<br>  xhr.onload = function(e) {<br>    if(this.status == 200||this.status == 304){<br>        alert(this.responseText);<br>    }<br>  };<br>  xhr.ontimeout = function(e) { … };<br>  xhr.onerror = function(e) { … };<br>  xhr.upload.onprogress = function(e) { … };</p>
<p>  //发送数据<br>  xhr.send(formData);<br>}<br>上面是一个使用xhr发送表单数据的示例，整个流程可以参考注释。</p>
<p>接下来我将站在使用者的角度，以问题的形式介绍xhr的基本使用。<br>我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。</p>
<p>如何设置request header<br>在发送Ajax请求（实质是一个HTTP请求）时，我们可能需要设置一些请求头部信息，比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。</p>
<p>void setRequestHeader(DOMString header, DOMString value);</p>
<p>注意点：</p>
<p>方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type;</p>
<p>Content-Type的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节；</p>
<p>setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错；</p>
<p>setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。下面是一个示例代码：</p>
<p>var client = new XMLHttpRequest();<br>client.open(‘GET’, ‘demo.cgi’);<br>client.setRequestHeader(‘X-Test’, ‘one’);<br>client.setRequestHeader(‘X-Test’, ‘two’);<br>// 最终request header中”X-Test”为: one, two<br>client.send();<br>如何获取response header<br>xhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，getResponseHeader(header)的header参数不区分大小写。</p>
<p>DOMString getAllResponseHeaders();<br>DOMString getResponseHeader(DOMString header);</p>
<p>这2个方法看起来简单，但却处处是坑儿。</p>
<p>你是否遇到过下面的坑儿?——反正我是遇到了。。。</p>
<p>使用getAllResponseHeaders()看到的所有response header与实际在控制台 Network 中看到的 response header 不一样</p>
<p>使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header “XXX”</p>
<p>经过一番寻找最终在 Stack Overflow找到了答案。</p>
<p>原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2这2个字段，无论是同域还是跨域请求；</p>
<p>原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” （两个名词的解释见下方）。</p>
<p>“simple response header”包括的 header 字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;<br>“Access-Control-Expose-Headers”：首先得注意是”Access-Control-Expose-Headers”进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。</p>
<p>所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。</p>
<p>如何指定xhr.response的数据类型<br>有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？<br>有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。</p>
<p>xhr.overrideMimeType()<br>overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type，这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType(‘text/xml; charset = utf-8’)来实现。</p>
<p>再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。</p>
<p>下面是一个获取图片文件的代码示例：</p>
<p>var xhr = new XMLHttpRequest();<br>//向 server 端获取一张图片<br>xhr.open(‘GET’, ‘/path/to/image.png’, true);</p>
<p>// 这行是关键！<br>//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集<br>xhr.overrideMimeType(‘text/plain; charset=x-user-defined’);</p>
<p>xhr.onreadystatechange = function(e) {<br>  if (this.readyState == 4 &amp;&amp; this.status == 200) {<br>    //通过 responseText 来获取图片文件对应的二进制字符串<br>    var binStr = this.responseText;<br>    //然后自己再想方法将逐个字节还原为二进制数据<br>    for (var i = 0, len = binStr.length; i &lt; len; ++i) {<br>      var c = binStr.charCodeAt(i);<br>      //String.fromCharCode(c &amp; 0xff);<br>      var byte = c &amp; 0xff;<br>    }<br>  }<br>};</p>
<p>xhr.send();<br>代码示例中xhr请求的是一张图片，通过将 response 的 content-type 改为’text/plain; charset=x-user-defined’，使得 xhr 以纯文本格式来解析接收到的blob 数据，最终用户通过this.responseText拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。</p>
<p>xhr.responseType<br>responseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可以参考本文的【XMLHttpRequest的兼容性】这一小节。那么responseType可以设置为哪些格式呢，我简单做了一个表，如下：</p>
<p>值    xhr.response 数据类型    说明<br>“”    String字符串    默认值(在不设置responseType时)<br>“text”    String字符串<br>“document”    Document对象    希望返回 XML 格式数据时使用<br>“json”    javascript 对象    存在兼容性问题，IE10/IE11不支持<br>“blob”    Blob对象<br>“arrayBuffer”    ArrayBuffer对象<br>下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.open(‘GET’, ‘/path/to/image.png’, true);<br>//可以将<code>xhr.responseType</code>设置为<code>&quot;blob&quot;</code>也可以设置为<code>&quot; arrayBuffer&quot;</code><br>//xhr.responseType = ‘arrayBuffer’;<br>xhr.responseType = ‘blob’;</p>
<p>xhr.onload = function(e) {<br>  if (this.status == 200) {<br>    var blob = this.response;<br>    …<br>  }<br>};</p>
<p>xhr.send();<br>小结<br>虽然在xhr level 2中，2者是共同存在的。但其实不难发现，xhr.responseType就是用来取代xhr.overrideMimeType()的，xhr.responseType功能强大的多，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。</p>
<p>如何获取response数据<br>xhr提供了3个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML</p>
<p>xhr.response</p>
<p>默认值：空字符串””</p>
<p>当请求完成时，此属性才有正确的值</p>
<p>请求未完成时，此属性的值可能是””或者 null，具体与 xhr.responseType有关：当responseType为””或”text”时，值为””；responseType为其他值时，值为 null</p>
<p>xhr.responseText</p>
<p>默认值为空字符串””</p>
<p>只有当 responseType 为”text”、””时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错</p>
<p>只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串””：请求未完成、请求失败</p>
<p>xhr.responseXML</p>
<p>默认值为 null</p>
<p>只有当 responseType 为”text”、””、”document”时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错</p>
<p>只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</p>
<p>如何追踪ajax请求的当前状态<br>在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？</p>
<p>用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。</p>
<p>  xhr.onreadystatechange = function () {<br>    switch(xhr.readyState){<br>      case 1://OPENED<br>        //do something<br>            break;<br>      case 2://HEADERS_RECEIVED<br>        //do something<br>        break;<br>      case 3://LOADING<br>        //do something<br>        break;<br>      case 4://DONE<br>        //do something<br>        break;<br>    }<br>值    状态    描述<br>0    UNSENT (初始状态，未打开)    此时xhr对象被成功构造，open()方法还未被调用<br>1    OPENED (已打开，未发送)    open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错<br>2    HEADERS_RECEIVED (已获取响应头)    send()方法已经被调用, 响应头和响应状态已经返回<br>3    LOADING (正在下载响应体)    响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据<br>4    DONE (整个数据传输过程结束)    整个数据传输过程结束，不管本次请求是成功还是失败<br>如何设置请求的超时时间<br>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。</p>
<p>xhr.timeout</p>
<p>单位：milliseconds 毫秒<br>默认值：0，即不设置超时</p>
<p>很多同学都知道：从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。</p>
<p>【那么到底什么时候才算是请求开始 ？】<br>——xhr.onloadstart事件触发的时候，也就是你调用xhr.send()方法的时候。<br>因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。</p>
<p>【那么什么时候才算是请求结束 ？】<br>—— xhr.loadend事件触发的时候。</p>
<p>另外，还有2个需要注意的坑儿：</p>
<p>可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。</p>
<p>当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。</p>
<p>如何发一个同步请求<br>xhr默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由xhr.open（）传入的async参数决定。</p>
<p>open(method, url [, async = true [, username = null [, password = null]]])</p>
<p>method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写</p>
<p>url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如<a href="http://www.example.com/example.php" target="_blank" rel="noopener">http://www.example.com/example.php</a></p>
<p>async: 默认值为true，即为异步请求，若async=false，则为同步请求</p>
<p>在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。</p>
<p>W3C 的 xhr标准中关于open()方法有这样一段说明：</p>
<p>Throws an “InvalidAccessError” exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string.</p>
<p>从上面一段说明可以知道，当xhr为同步请求时，有如下限制：</p>
<p>xhr.timeout必须为0</p>
<p>xhr.withCredentials必须为 false</p>
<p>xhr.responseType必须为””（注意置为”text”也不允许）</p>
<p>若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。</p>
<p>之前说过页面中应该尽量避免使用sync同步请求，为什么呢？<br>因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。</p>
<p>另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。</p>
<p>如何获取上传、下载的进度<br>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。<br>我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件：</p>
<p>上传触发的是xhr.upload对象的 onprogress事件</p>
<p>下载触发的是xhr对象的onprogress事件</p>
<p>xhr.onprogress = updateProgress;<br>xhr.upload.onprogress = updateProgress;<br>function updateProgress(event) {<br>    if (event.lengthComputable) {<br>      var completedPercent = event.loaded / event.total;<br>    }<br> }<br>可以发送什么类型的数据<br>void send(data);</p>
<p>xhr.send(data)的参数data可以是以下几种类型：</p>
<p>ArrayBuffer</p>
<p>Blob</p>
<p>Document</p>
<p>DOMString</p>
<p>FormData</p>
<p>null</p>
<p>如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使你真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null.</p>
<p>xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值：</p>
<p>如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8；</p>
<p>如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8；</p>
<p>如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx]</p>
<p>如果data是其他类型，则不会设置content-type的默认值</p>
<p>当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。</p>
<p>另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute ‘send’ on ‘XMLHttpRequest’。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。</p>
<p>try{<br>    xhr.send(data)<br>  }catch(e) {<br>    //doSomething…<br>  };<br>xhr.withCredentials与 CORS 什么关系<br>我们都知道，在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。</p>
<p>造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（credentials）如”cookies”和”HTTP authentication schemes”。除非xhr.withCredentials为true（xhr对象有一个属性叫withCredentials，默认值为false）。</p>
<p>所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。</p>
<p>另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，而必须设置为请求页面的域名。</p>
<p>xhr相关事件<br>事件分类<br>xhr相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是XMLHttpRequest的部分实现代码：</p>
<p>interface XMLHttpRequestEventTarget : EventTarget {<br>  // event handlers<br>  attribute EventHandler onloadstart;<br>  attribute EventHandler onprogress;<br>  attribute EventHandler onabort;<br>  attribute EventHandler onerror;<br>  attribute EventHandler onload;<br>  attribute EventHandler ontimeout;<br>  attribute EventHandler onloadend;<br>};</p>
<p>interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {</p>
<p>};</p>
<p>interface XMLHttpRequest : XMLHttpRequestEventTarget {<br>  // event handler<br>  attribute EventHandler onreadystatechange;<br>  readonly attribute XMLHttpRequestUpload upload;<br>};<br>从代码中我们可以看出：</p>
<p>XMLHttpRequestEventTarget接口定义了7个事件：</p>
<p>onloadstart</p>
<p>onprogress</p>
<p>onabort</p>
<p>ontimeout</p>
<p>onerror</p>
<p>onload</p>
<p>onloadend</p>
<p>每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象</p>
<p>XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件</p>
<p>onreadystatechange是XMLHttpRequest独有的事件</p>
<p>所以这么一看就很清晰了：<br>xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。</p>
<p>事件触发条件<br>下面是我自己整理的一张xhr相关事件触发条件表，其中最需要注意的是 onerror 事件的触发条件。</p>
<p>事件    触发条件<br>onreadystatechange    每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。<br>onloadstart    调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。<br>onprogress    xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。<br>onload    当请求成功完成时触发，此时xhr.readystate=4<br>onloadend    当请求结束（包括请求成功和请求失败）时触发<br>onabort    当调用xhr.abort()后触发<br>ontimeout    xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。<br>onerror    在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。<br>事件触发顺序<br>当请求一切正常时，相关的事件触发顺序如下：</p>
<p>触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次)</p>
<p>触发xhr.onloadstart<br>//上传阶段开始：</p>
<p>触发xhr.upload.onloadstart</p>
<p>触发xhr.upload.onprogress</p>
<p>触发xhr.upload.onload</p>
<p>触发xhr.upload.onloadend<br>//上传结束，下载阶段开始：</p>
<p>触发xhr.onprogress</p>
<p>触发xhr.onload</p>
<p>触发xhr.onloadend</p>
<p>发生abort/timeout/error异常的处理<br>在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下：</p>
<p>一旦发生abort或timeout或error异常，先立即中止当前请求</p>
<p>将 readystate 置为4，并触发 xhr.onreadystatechange事件</p>
<p>如果上传阶段还没有结束，则依次触发以下事件：</p>
<p>xhr.upload.onprogress</p>
<p>xhr.upload.[onabort或ontimeout或onerror]</p>
<p>xhr.upload.onloadend</p>
<p>触发 xhr.onprogress事件</p>
<p>触发 xhr.[onabort或ontimeout或onerror]事件</p>
<p>触发xhr.onloadend 事件</p>
<p>在哪个xhr事件中注册成功回调？<br>从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。</p>
<p>xhr.onload = function () {<br>    //如果请求成功<br>    if(xhr.status == 200){<br>      //do successCallback<br>    }<br>  }<br>上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。</p>
<p>  xhr.onload = function () {<br>    //如果请求成功<br>    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){<br>      //do successCallback<br>    }<br>  }<br>结语<br>终于写完了……<br>看完那一篇长长的W3C的xhr 标准，我眼睛都花了……<br>希望这篇总结能帮助刚开始接触XMLHttpRequest的你。</p>
<p>最后给点扩展学习资料，如果你：</p>
<p>想真正搞懂XMLHttpRequest，最靠谱的方法还是看 W3C的xhr 标准;</p>
<p>想结合代码学习如何用XMLHttpRequest发各种类型的数据，可以参考html5rocks上的这篇文章</p>
<p>想粗略的了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍；</p>
<p>想了解XMLHttpRequest 的发展历程，可以参考阮老师的文章；</p>
<p>想了解Ajax的基本介绍，可以参考AJAX Tutorial;</p>
<p>想了解跨域请求，则可以参考W3C的 cors 标准;</p>
<p>想了解http协议，则可以参考HTTP Tutorial;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/聊聊cookie-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/聊聊cookie-转/" itemprop="url">聊聊cookie(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T14:04:47+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://juejin.im/post/59d1f59bf265da06700b0934" target="_blank" rel="noopener">参考链接1</a><br><a href="https://segmentfault.com/a/1190000004556040" target="_blank" rel="noopener">参考链接2</a></p>
<h2 id="cookie是什么"><a href="#cookie是什么" class="headerlink" title="cookie是什么"></a>cookie是什么</h2><p>这个讲起来很简单，了解http的同学，肯定知道，http是一个不保存状态的协议，什么叫不保存状态，就是一个服务器是不清楚是不是同一个浏览器在访问他，在cookie之前，有另外的技术是可以解决，这里简单讲一下，就是在请求中插入一个token，然后在发送请求的时候，把这个东西带给服务器，这种方式是易出错，所以有了cookie的出现</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/2/9749a2f293a5b4f84d8a40b4e8657faf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cookie是什么"></p>
<h2 id="cookie原理"><a href="#cookie原理" class="headerlink" title="cookie原理"></a><code>cookie</code>原理</h2><p><img src="https://user-gold-cdn.xitu.io/2017/10/2/07ecb36c4820a66de90013f303cac8c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cookie原理"></p>
<p>第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将cookie放入到响应请求中，在浏览器第二次发请求的时候，会把cookie带过去，服务端会辨别用户身份，当然服务器也可以修改cookie内容</p>
<h2 id="cookie不可跨域"><a href="#cookie不可跨域" class="headerlink" title="cookie不可跨域"></a><code>cookie</code>不可跨域</h2><p>我就几个例子你就懂了，当我打开百度的网页，我要设置一个cookie的时候，我的指令如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">'myname=laihuamin;path=/;domain=.baidu.com'</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">'myname=huaminlai;path=/;domain=.google.com'</span>;</span><br></pre></td></tr></table></figure>
<p>当我将这两个语句都放到浏览器控制台运行的时候，你会发现一点,注意，上面两个cookie的值是不相同的，看清楚:</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/2/ef12b6b1b2590434c959161d39fc7adc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cookie不可跨域"></p>
<p>显而易见的是，真正能把cookie设置上去的只有domain是.baidu.com的cookie绑定到了域名上，所以上面所说的不可跨域性，就是不能在不同的域名下用，每个cookie都会绑定单一的域名。</p>
<h2 id="cookie的格式"><a href="#cookie的格式" class="headerlink" title="cookie的格式"></a>cookie的格式</h2><p>JS原生的API提供了获取<code>cookie</code>的方法：<code>document.cookie</code>（注意，这个方法只能获取非<code>HttpOnly</code>类型的<code>cookie</code>）。在<code>console</code>中执行这段代码可以看到结果如下图：</p>
<p><img src="https://image-static.segmentfault.com/124/862/1248624194-56dd2f47053e4_articlex" alt="cookie格式"></p>
<h2 id="cookie属性"><a href="#cookie属性" class="headerlink" title="cookie属性"></a><code>cookie</code>属性</h2><p>每个<code>cookie</code>都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过<code>cookie</code>选项来设置的，<code>cookie</code>选项包括：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>HttpOnly</code>。在设置任一个<code>cookie</code>时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个分号和一个空格隔开。代码示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly"</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/2/88a294c5374093cedd41bb1ce50cd9d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cookie属性"></p>
<ul>
<li><code>name</code></li>
<li><code>value</code></li>
<li><code>domain</code></li>
<li><code>path</code></li>
<li><code>expires</code></li>
<li><code>secure</code></li>
<li><code>HttpOnly</code></li>
</ul>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a><code>name</code></h3><p>这个显而易见，就是代表cookie的名字的意思，一个域名下绑定的cookie，name不能相同，相同的name的值会被覆盖掉，有兴趣的同学可以试一试，我在项目中切实用到过。</p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a><code>value</code></h3><p>这个就是每个cookie拥有的一个属性，它表示cookie的值，但是我在这里想说的不是这个，因为我在网上看到两种说法，如下：</p>
<ol>
<li>cookie的值必须被URL编码</li>
<li>对cookie的值进行编码不是必须的，还举了原始文档中所说的，仅对三种符号必须进行编码：分号、逗号和空格</li>
</ol>
<p>这个东西得一分为二来看，先看下面的图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/2/fb6f3ec85759285e8e9eb57fd979078b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="value"></p>
<p>我在网上看到那么一种说法：</p>
<blockquote>
<p>由于cookie规定是名称/值是不允许包含分号，逗号，空格的，所以为了不给用户到来麻烦，考虑服务器的兼容性，任何存储cookie的数据都应该被编码。</p>
</blockquote>
<h3 id="domain和path"><a href="#domain和path" class="headerlink" title="domain和path"></a><code>domain</code>和<code>path</code></h3><p><code>domain</code>是域名，<code>path</code>是路径，两者加起来就构成了 URL，<code>domain</code>和<code>path</code>一起来限制<code>cookie</code>能被哪些 URL 访问。</p>
<p>一句话概括：某<code>cookie</code>的<code>domain</code>为<code>“baidu.com”</code>, <code>path</code>为<code>“/ ”</code>，若请求的URL(URL可以是<code>js/html/img/css</code>资源请求，但不包括<code>XHR</code>请求)的域名是<code>“baidu.com”</code>或其子域如<code>“api.baidu.com”</code>、<code>“dev.api.baidu.com”</code>，且 URL 的路径是<code>“/ ”</code>或子路径<code>“/home”</code>、<code>“/home/login”</code>，则浏览器会将此 <code>cookie</code> 添加到该请求的 <code>cookie</code> 头部中。</p>
<p>所以<code>domain</code>和<code>path</code>2个选项共同决定了<code>cookie</code>何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。<code>domain</code>的默认值为设置该<code>cookie</code>的网页所在的域名，<code>path</code>默认值为设置该<code>cookie</code>的网页所在的目录。</p>
<blockquote>
<p>特别说明1：<br>发生跨域xhr请求时，即使请求URL的域名和路径都满足 <code>cookie</code> 的 <code>domain</code> 和 <code>path</code>，默认情况下<code>cookie</code>也不会自动被添加到请求头部中。若想知道原因请阅读本文最后一节）</p>
<p>特别说明2：<br><code>domain</code>是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀<code>public suffix</code>。举例说明下：如果页面域名为<code>www.baidu.com</code>, <code>domain</code>可以设置为<code>“www.baidu.com”</code>，也可以设置为<code>“baidu.com”</code>，但不能设置为<code>“.com”</code>或<code>“com”</code>。</p>
</blockquote>
<h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a><code>expires</code></h3><p><img src="https://user-gold-cdn.xitu.io/2017/10/2/348aab52f1892d29ecd3a1e5e5167cb9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="expires"></p>
<p><code>expires</code>选项用来设置“<code>cookie</code>什么时间内有效”。</p>
<p><code>expires</code>其实是<code>cookie</code>失效日期，<code>expires</code>必须是<code>GMT</code>格式的时间（可以通过<code>new Date().toGMTString()</code>或者<code>new Date().toUTCString()</code>来获得）。如<code>expires=Thu, 25 Feb 2016 04:18:00 GMT</code>表示<code>cookie</code>讲在2016年2月25日4:18分之后失效，对于失效的<code>cookie</code>浏览器会清空。</p>
<p>如果没有设置该选项，则默认有效期为<code>session</code>，即会话<code>cookie</code>。这种<code>cookie</code>在浏览器关闭后就没有了。</p>
<blockquote>
<p>expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。expires的值是一个时间点（cookie失效时刻= expires），而max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻+ max-age）。<br>另外，max-age 的默认值是 -1(即有效期为 session )；若max-age有三种可能值：负数、0、正数。负数：有效期session；0：删除cookie；正数：有效期为创建时刻+ max-age</p>
</blockquote>
<p>如果你想要<code>cookie</code>存在一段时间，那么你可以通过设置<code>Expires</code>属性为未来的一个时间节点，<code>Expires</code>这个是代表当前时间的，这个属性已经逐渐被我们下面这个主人公所取代——Max-Age。</p>
<p>Max-Age，是以秒为单位的。</p>
<ul>
<li>Max-Age为正数时，<code>cookie</code>会在Max-Age秒之后，被删除。</li>
<li>当Max-Age为负数时，表示的是临时储存，不会生出<code>cookie</code>文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，<code>cookie</code>就会消失。</li>
<li>当Max-Age为0时，又会发生什么呢，删除<code>cookie</code>，因为<code>cookie</code>机制本身没有设置删除<code>cookie</code>，失效的<code>cookie</code>会被浏览器自动从内存中删除，所以，它实现的就是让<code>cookie</code>失效。</li>
</ul>
<h3 id="secure"><a href="#secure" class="headerlink" title="secure"></a><code>secure</code></h3><p><img src="https://user-gold-cdn.xitu.io/2017/10/2/dd48df2362163b22d8d69d21918d8835?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="secure"></p>
<p>这个属性译为安全，http不仅是无状态的，还是不安全的协议，容易被劫持，打个比方，你在手机端浏览网页的时候，有没有中国移动图标跳出来过，闲言少叙，当这个属性设置为true时，此cookie只会在https和ssl等安全协议下传输</p>
<p><strong>提示：</strong> <em>这个属性并不能对客户端的cookie进行加密，不能保证绝对的安全性。</em></p>
<h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a><code>HttpOnly</code></h3><p>这个属性是面试的时候常考的，如果这个属性设置为true，就不能通过js脚本来获取cookie的值，能有效的防止xss攻击,看MDN的官方文档：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/2/cf582beb568a79b1d9dd8ef97be707f6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="HttpOnly"></p>
<blockquote>
<p>——httpOnly与安全</p>
<p>从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问cookie？其实这样做是为了保障安全。</p>
<p>试想：如果任何 cookie 都能被客户端通过document.cookie获取会发生什么可怕的事情。当我们的网页遭受了 XSS 攻击，有一段恶意的script脚本插到了网页中。这段script脚本做的事情是：通过document.cookie读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。</p>
</blockquote>
<h2 id="关于js操作cookie"><a href="#关于js操作cookie" class="headerlink" title="关于js操作cookie"></a>关于js操作<code>cookie</code></h2><p>document.cookie可以对cookie进行读写，看一下两条指令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取浏览器中的cookie</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="comment">//写入cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie=<span class="string">"age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/"</span>;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>客户端可以设置cookie 的下列选项：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>（有条件：只有在<code>https</code>协议的网页中，客户端设置<code>secure</code>类型的<code>cookie</code>才能成功），但无法设置<code>HttpOnly</code>选项。</li>
</ul>
<h3 id="设置多个cookie"><a href="#设置多个cookie" class="headerlink" title="设置多个cookie"></a>设置多个<code>cookie</code></h3><p>当要设置多个<code>cookie</code>时， js代码很自然地我们会这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=Jonh; age=12; class=111"</span>;</span><br></pre></td></tr></table></figure>
<p>但你会发现这样写只是添加了第一个<code>cookie`</code>“name=John”<code>，后面的所有</code>cookie<code>都没有添加成功。所以最简单的设置多个</code>cookie<code>的方法就在重复执行</code>document.cookie = “key=name”`，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=Jonh"</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"age=12"</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"class=111"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="服务端如何设置cookie"><a href="#服务端如何设置cookie" class="headerlink" title="服务端如何设置cookie"></a>服务端如何设置<code>cookie</code></h2><p>关于怎么设置cookie，我们只要打开控制台，看一个http的请求头和响应头中的东西即可明白：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/2/ac1f0d4e46b21da20d76b8136dd7583f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="服务端如何设置cookie"></p>
<p>不管你是请求一个资源文件（如<code>html/js/css/image</code>），还是发送一个<code>ajax</code>请求，服务端都会返回<code>response</code>。而<code>response header</code>中有一项叫<code>set-cookie</code>，是服务端专门用来设置<code>cookie</code>的。如下图所示，服务端返回的<code>response header</code>中有5个<code>set-cookie</code>字段，每个字段对应一个<code>cookie</code>（注意不能将多个<code>cookie</code>放在一个<code>set-cookie</code>字段中），<code>set-cookie</code>字段的值就是普通的字符串，每个<code>cookie</code>还设置了相关属性选项。</p>
<p>注意：</p>
<ul>
<li>一个<code>Set-Cookie</code>字段只能设置一个<code>cookie</code>，当你要想设置多个 <code>cookie</code>，需要添加同样多的<code>Set-Cookie</code>字段。</li>
<li>服务端可以设置<code>cookie</code> 的所有选项：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>HttpOnly</code></li>
</ul>
<h2 id="我们看到的cookie"><a href="#我们看到的cookie" class="headerlink" title="我们看到的cookie"></a>我们看到的<code>cookie</code></h2><p>发送一个AJAX请求，<code>header</code>如下图：</p>
<p><img src="https://image-static.segmentfault.com/239/160/2391604247-56dd2eafae06e_articlex" alt="我们看到的cookie"></p>
<p>从上图中我们会看到<code>request header</code>中自动添加了<code>Cookie</code>字段（我并没有手动添加这个字段哦~），<code>Cookie</code>字段的值其实就是我设置的那4个<code>cookie</code>。这个请求最终会发送到<code>http://ppsc.sankuai.com</code>这个服务器上，这个服务器就能从接收到的<code>request header</code>中提取那4个<code>cookie</code>。</p>
<p>上图展示了<code>cookie</code>的基本通信流程：设置<code>cookie</code> =&gt; <code>cookie</code>被自动添加到<code>request header</code>中 =&gt; 服务端接收到<code>cookie</code>。这个流程中有几个问题需要好好研究：</p>
<ol>
<li>什么样的数据适合放在<code>cookie</code>中？</li>
<li><code>cookie</code>是怎么设置的？</li>
<li><code>cookie</code>为什么会自动加到<code>request header</code>中？</li>
<li><code>cookie</code>怎么增删查改？</li>
</ol>
<p>我们要带着这几个问题继续往下阅读。</p>
<h2 id="cookie是怎么工作的？"><a href="#cookie是怎么工作的？" class="headerlink" title="cookie是怎么工作的？"></a><code>cookie</code>是怎么工作的？</h2><p>首先必须明确一点，存储<code>cookie</code>是浏览器提供的功能。<code>cookie</code>其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个<code>cookie</code>文件夹来存放各个域下设置的<code>cookie</code>。</p>
<p>当网页要发<code>http</code>请求时，浏览器会先检查是否有相应的<code>cookie</code>，有则自动添加在<code>request header</code>中的<code>cookie</code>字段中。这些是浏览器自动帮我们做的，而且每一次<code>http</code>请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在<code>cookie</code>中”。</p>
<p>存储在<code>cookie</code>中的数据，每次都会被浏览器自动放在<code>http</code>请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在<code>cookie</code>中，其他类型的数据就不适合了。</p>
<p>但在<code>localStorage</code>出现之前，<code>cookie</code>被滥用当做了存储工具。什么数据都放在<code>cookie</code>中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然<code>cookie</code>标准还是做了一些限制的：每个域名下的<code>cookie</code>的大小最大为<code>4KB</code>，每个域名下的<code>cookie</code>数量最多为<code>20</code>个（但很多浏览器厂商在具体实现时支持大于<code>20</code>个）。</p>
<h2 id="如何修改、删除"><a href="#如何修改、删除" class="headerlink" title="如何修改、删除"></a>如何修改、删除</h2><h3 id="修改cookie"><a href="#修改cookie" class="headerlink" title="修改cookie"></a>修改<code>cookie</code></h3><p>要想修改一个<code>cookie</code>，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新<code>cookie</code>时，<code>path/domain</code>这几个选项一定要和旧<code>cookie</code>保持一样。否则不会修改旧值，而是添加了一个新的 <code>cookie</code>。</p>
<h3 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 <code>cookie</code></h3><p>删除一个<code>cookie</code>也挺简单，也是重新赋值，只要将这个新<code>cookie</code>的<code>expires</code>选项设置为一个过去的时间点就行了。但同样要注意，<code>path/domain</code>这几个选项一定要旧<code>cookie</code>保持一样。</p>
<h2 id="cookie-编码"><a href="#cookie-编码" class="headerlink" title="cookie 编码"></a><code>cookie</code> 编码</h2><p><code>cookie</code>其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当<code>cookie</code>的<code>key</code>和<code>value</code>中含有这3个特殊字符时，需要对其进行额外编码，一般会用<code>escape</code>进行编码，读取时用<code>unescape</code>进行解码；当然也可以用<code>encodeURIComponent/decodeURIComponent</code>或者<code>encodeURI/decodeURI</code>（<a href="http://www.cnblogs.com/season-huang/p/3439277.html" target="_blank" rel="noopener">三者的区别可以参考这篇文章</a>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="built_in">escape</span>(<span class="string">"name;value"</span>);</span><br><span class="line"><span class="keyword">var</span> value = <span class="built_in">escape</span>(<span class="string">"this is a value contain , and ;"</span>);</span><br><span class="line"><span class="built_in">document</span>.cookie= key + <span class="string">"="</span> + value + <span class="string">"; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="跨域请求中-cookie"><a href="#跨域请求中-cookie" class="headerlink" title="跨域请求中 cookie"></a>跨域请求中 <code>cookie</code></h2><p>之前在介绍 XHR 的一篇文章里面提过：默认情况下，在发生跨域时，<code>cookie</code>作为一种<code>credential</code>信息是不会被传送到服务端的。必须要进行额外设置才可以。具体原因和如何设置可以参考我的这篇文章：<a href="https://segmentfault.com/a/1190000004322487#articleHeader13" target="_blank" rel="noopener">你真的会使用XMLHttpRequest吗？</a></p>
<p>另外，关于跨域资源共享 CORS极力推荐大家阅读阮一峰老师的这篇 跨域资源共享 CORS 详解。</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><ol>
<li>什么时候 <code>cookie</code> 会被覆盖：<code>name/domain/path</code>这3个字段都相同的时候；</li>
<li>关于domain的补充说明（<a href="https://tools.ietf.org/html/rfc6265#section-5.2.3" target="_blank" rel="noopener">参考1</a>/<a href="http://erik.io/blog/2014/03/04/definitive-guide-to-cookie-domains/" target="_blank" rel="noopener">参考2</a>）：<ol>
<li>如果显式设置了 domain，则设置成什么，浏览器就存成什么；但如果没有显式设置，则浏览器会自动取 url 的 host 作为 domain 值；</li>
<li>新的规范中，显式设置 domain 时，如果 value 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的（注意：但目前大多数浏览器并未全部这么实现）</li>
<li>前面带点‘.’和不带点‘.’有啥区别：<ul>
<li>带点：任何 subdomain 都可以访问，包括父 domain</li>
<li>不带点：只有完全一样的域名才能访问，subdomain 不能（但在 IE 下比较特殊，它支持 subdomain 访问）</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>咱们今天就聊到这里，若有不对之处欢迎各位指正~~<br>最后附上一些参考资料：</p>
<ul>
<li><a href="http://www.quirksmode.org/js/cookies.html" target="_blank" rel="noopener">http://www.quirksmode.org/js/cookies.html</a></li>
<li><a href="http://www.tutorialspoint.com/javascript/javascript_cookies.htm" target="_blank" rel="noopener">http://www.tutorialspoint.com/javascript/javascript_cookies.htm</a></li>
<li><a href="http://www.allaboutcookies.org/cookies/cookies-the-same.html" target="_blank" rel="noopener">http://www.allaboutcookies.org/cookies/cookies-the-same.html</a></li>
<li><a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="noopener">http://bubkoo.com/2014/04/21/http-cookies-explained/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/25/浏览器同源政策及其规避方法-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/浏览器同源政策及其规避方法-转/" itemprop="url">浏览器同源政策及其规避方法(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-25T11:23:19+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">原文地址</a></p>
<p>最初，<em>同源策略</em>的含义是指，网页A设置的cookie，网页B不能打开，除非这两个网页“同源”，如下：</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>的同源情况如下：</p>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ul>
<p><em>同源策略</em>的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>随着互联网的发展，<em>同源策略</em>越来越严格，目前共有三种行为收到限制：</p>
<ol>
<li>Cookie、LocalStorage和IndexedDB无法读取；</li>
<li>DOM无法获得；</li>
<li>AJAX请求不能发送。</li>
</ol>
<h2 id="如何规避"><a href="#如何规避" class="headerlink" title="如何规避"></a>如何规避</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h3><p>Cookie是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享<code>cookie</code>。</p>
<p>举例来说，网页A是<code>http://w1.example.com/a.html</code>，网页B是<code>http://w2.example.com/b.html</code>。那么只要设置相同的<code>document.domain</code>，两个网页就可以共享<code>cookie</code>。</p>
<p>注意，这种方法只适用于<code>cookie</code>和<code>iframe</code>窗口，<code>LocalStorage</code>和<code>IndexedDB</code>是不行的，而要使用<code>PostMessage</code>API。</p>
<p>此外，服务器可以在设置<code>cookie</code>的时候，指定<code>cookie</code>所属域名为一级域名，比如<code>.example.com</code>，这样，二级域名和三级域名不用做任何设置，都可以读取这个<code>cookie</code>。</p>
<h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a><code>iframe</code></h3><p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是<code>iframe</code>和<code>window.open()</code>打开的窗口与父窗口无法通信。</p>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置<code>document.domain</code>属性就可以。</p>
<p>对于完全不同源的网站，目前有三种方法：</p>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>window.name</li>
<li>跨文档通信API（cross-document messageing）</li>
</ul>
<h4 id="片段识别符"><a href="#片段识别符" class="headerlink" title="片段识别符"></a>片段识别符</h4><p>片段识别符（fragment identifier）是指URL的<code>#</code>后面的部分，如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息写入子窗口的片段标识符，子窗口监听<code>hashchange</code>事件得到通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父</span></span><br><span class="line"><span class="keyword">const</span> src = <span class="string">`<span class="subst">$&#123;originURL&#125;</span>#<span class="subst">$&#123;data&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myIframe'</span>).src = src;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口也可以改变父窗口的片段标识符</span></span><br><span class="line">parent.location.href = <span class="string">`<span class="subst">$&#123;target&#125;</span>#<span class="subst">$&#123;hash&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>
<h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a><code>window.name</code></h4><p>无论是否同源，只要在一个窗口里，前一个网页设置的<code>window.name</code>，后一个网页就可以读取它。</p>
<p>优点是容量大，可以放置很长的字符串；缺点是必须监听属性变化的事件，影响性能。</p>
<h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a><code>postMessage</code></h4><p>HTML5提供了跨文档通信API（Cross-document messaging）<code>postMessage</code>，允许跨窗口通信，不论这两个窗口是否同源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口向子窗口</span></span><br><span class="line"><span class="keyword">const</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://b.com'</span>, <span class="string">'title'</span>);</span><br><span class="line">popup.postMessage(<span class="string">'hello'</span>, <span class="string">'http://b.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口向父窗口</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">'hello'</span>, <span class="string">'http://a.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; <span class="built_in">console</span>.log(e.data), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p><code>event</code>对象的三个属性：</p>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>：消息发向的网址</li>
<li><code>event.data</code>：消息内容</li>
</ul>
<h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a><code>LocalStorage</code></h4><p>通过<code>window.postMessage</code>可以读写其他窗口的<code>LocalStorage</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子窗口接收父窗口消息</span></span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin !== <span class="string">'http://bbb.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> payload = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">  <span class="keyword">switch</span> (payload.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'set'</span>:</span><br><span class="line">      localStorage.setItem(payload.key, <span class="built_in">JSON</span>.stringify(payload.data));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'get'</span>:</span><br><span class="line">      <span class="keyword">const</span> parent = <span class="built_in">window</span>.parent;</span><br><span class="line">      <span class="keyword">const</span> data = localStorage.getItem(payload.key);</span><br><span class="line">      parent.postMessage(data, <span class="string">'http://aaa.com'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'remove'</span>:</span><br><span class="line">      localStorage.removeItem(payload.key);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父窗口发消息</span></span><br><span class="line"><span class="keyword">const</span> win = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'iframe'</span>)[<span class="number">0</span>].contentWindow;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'Jack'</span> &#125;;</span><br><span class="line"><span class="comment">// 存入对象</span></span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">'set'</span>, <span class="attr">data</span>: obj&#125;), <span class="string">'http://bbb.com'</span>);</span><br><span class="line"><span class="comment">// 读取对象</span></span><br><span class="line">win.postMessage(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">key</span>: <span class="string">'storage'</span>, <span class="attr">method</span>: <span class="string">"get"</span>&#125;), <span class="string">"*"</span>);</span><br><span class="line"><span class="built_in">window</span>.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.origin != <span class="string">'http://aaa.com'</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// "Jack"</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(e.data).name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>AJAX请求只能发给同源网址，有三种方法规避这个限制：</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/24/提及-实现-转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/提及-实现-转/" itemprop="url">@提及 实现(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T23:59:14+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.zhihu.com/question/20238997/answer/14445045" target="_blank" rel="noopener">原文链接</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://buptlyz.github.io/2019/04/24/我的华丽的Zsh提词My-Extravagant-Zsh-Prompt-译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="沙雕爹爹">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕爹爹">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/我的华丽的Zsh提词My-Extravagant-Zsh-Prompt-译/" itemprop="url">我的华丽的Zsh提词My Extravagant Zsh Prompt(译)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-24T21:54:46+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://stevelosh.com/blog/2010/02/my-extravagant-zsh-prompt/" target="_blank" rel="noopener">原文地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">沙雕爹爹</p>
              <p class="site-description motion-element" itemprop="description">Personal tech blog.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">45</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">沙雕爹爹</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
